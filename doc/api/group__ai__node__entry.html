<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arnold 4.2.14.2 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">AtNodeEntry API</div>  </div>
</div><!--header-->
<div class="contents">

<p>For a discussion of Arnold's object-oriented system of pluggable nodes, please refer to <a class="el" href="group__ai__nodes.html">AtNode API</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtCommonMethods.html">AtCommonMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods common to all nodes.  <a href="structAtCommonMethods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtNodeMethods.html">AtNodeMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node methods.  <a href="structAtNodeMethods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtMetaDataEntry.html">AtMetaDataEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtNodeEntry.html">AtNodeEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a node type in Arnold.  <a href="structAtNodeEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Types</h2></td></tr>
<tr class="memitem:ga2ca2a3cc668472f3d8b2a745bb28099b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ca2a3cc668472f3d8b2a745bb28099b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga2ca2a3cc668472f3d8b2a745bb28099b">AI_NODE_UNDEFINED</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:ga2ca2a3cc668472f3d8b2a745bb28099b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undefined type. <br /></td></tr>
<tr class="separator:ga2ca2a3cc668472f3d8b2a745bb28099b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7eae92aa44ac7b928e50b1f4e0fcb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb7eae92aa44ac7b928e50b1f4e0fcb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gabb7eae92aa44ac7b928e50b1f4e0fcb6">AI_NODE_OPTIONS</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:gabb7eae92aa44ac7b928e50b1f4e0fcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options node (following the "singleton" pattern, there is only one options node) <br /></td></tr>
<tr class="separator:gabb7eae92aa44ac7b928e50b1f4e0fcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857f664c28910030841a774bf1898d0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga857f664c28910030841a774bf1898d0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga857f664c28910030841a774bf1898d0a">AI_NODE_CAMERA</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:ga857f664c28910030841a774bf1898d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Camera nodes (<code>persp_camera</code>, <code>fisheye_camera</code>, etc) <br /></td></tr>
<tr class="separator:ga857f664c28910030841a774bf1898d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09bae1a8d33f8394318cd7960984b82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf09bae1a8d33f8394318cd7960984b82"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaf09bae1a8d33f8394318cd7960984b82">AI_NODE_LIGHT</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:gaf09bae1a8d33f8394318cd7960984b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Light source nodes (<code>spot_light</code>, etc) <br /></td></tr>
<tr class="separator:gaf09bae1a8d33f8394318cd7960984b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da98c230027a66005c322e0b72a94e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5da98c230027a66005c322e0b72a94e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga5da98c230027a66005c322e0b72a94e6">AI_NODE_SHAPE</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:ga5da98c230027a66005c322e0b72a94e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geometry nodes (<code>sphere</code>, <code>polymesh</code>, etc) <br /></td></tr>
<tr class="separator:ga5da98c230027a66005c322e0b72a94e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76527e5c085e5bdda7de726f8f3cba9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga76527e5c085e5bdda7de726f8f3cba9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga76527e5c085e5bdda7de726f8f3cba9e">AI_NODE_SHADER</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:ga76527e5c085e5bdda7de726f8f3cba9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shader nodes (<code>lambert</code>, etc) <br /></td></tr>
<tr class="separator:ga76527e5c085e5bdda7de726f8f3cba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb2a30fa9c732a4d5a04b05b248f6c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaeb2a30fa9c732a4d5a04b05b248f6c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaaeb2a30fa9c732a4d5a04b05b248f6c8">AI_NODE_OVERRIDE</a>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:gaaeb2a30fa9c732a4d5a04b05b248f6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: override nodes support "delayed parameter overrides" for <code>procedural</code> nodes. <br /></td></tr>
<tr class="separator:gaaeb2a30fa9c732a4d5a04b05b248f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97634759e5d4dd48e2de3b17016c4ef9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga97634759e5d4dd48e2de3b17016c4ef9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga97634759e5d4dd48e2de3b17016c4ef9">AI_NODE_DRIVER</a>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:ga97634759e5d4dd48e2de3b17016c4ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output driver nodes (<code>driver_tiff</code>, etc) <br /></td></tr>
<tr class="separator:ga97634759e5d4dd48e2de3b17016c4ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c0e7ae078b369318f1a5e93805d7d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0c0e7ae078b369318f1a5e93805d7d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaa0c0e7ae078b369318f1a5e93805d7d3">AI_NODE_FILTER</a>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:gaa0c0e7ae078b369318f1a5e93805d7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel sample filter nodes (<code>box_filter</code>, etc. <br /></td></tr>
<tr class="separator:gaa0c0e7ae078b369318f1a5e93805d7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf029c124baf82592ee04a8a303be9d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf029c124baf82592ee04a8a303be9d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaaf029c124baf82592ee04a8a303be9d8">AI_NODE_ALL</a>&#160;&#160;&#160;0xFFFF</td></tr>
<tr class="memdesc:gaaf029c124baf82592ee04a8a303be9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask including all node types, used by <a class="el" href="group__ai__dotass.html#ga39f5a4ac030a25c17ad9c7a4d4fbd939" title="Write all nodes in the scene to an .ass file. ">AiASSWrite()</a> <br /></td></tr>
<tr class="separator:gaaf029c124baf82592ee04a8a303be9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
AtNodeEntry Methods</h2></td></tr>
<tr class="memitem:ga2c720b283ecc3d69edf18b9049269ad7"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEPRECATED AI_PURE const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga2c720b283ecc3d69edf18b9049269ad7">AiNodeEntryLookUp</a> (const char *name)</td></tr>
<tr class="memdesc:ga2c720b283ecc3d69edf18b9049269ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a node entry from a name string.  <a href="#ga2c720b283ecc3d69edf18b9049269ad7">More...</a><br /></td></tr>
<tr class="separator:ga2c720b283ecc3d69edf18b9049269ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad0ffb3f8cf6b39c7e9af1c9ef2d846a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad0ffb3f8cf6b39c7e9af1c9ef2d846a"></a>
AI_API AI_PURE const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeEntryLookUpAtString</b> (const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:gaad0ffb3f8cf6b39c7e9af1c9ef2d846a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c7c890ff120acf969a55a49cc83e01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga01c7c890ff120acf969a55a49cc83e01"></a>
AI_PURE const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeEntryLookUp</b> (const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:ga01c7c890ff120acf969a55a49cc83e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab181cd27be267b76e7deb56e56227628"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gab181cd27be267b76e7deb56e56227628">AiNodeEntryGetName</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gab181cd27be267b76e7deb56e56227628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>.  <a href="#gab181cd27be267b76e7deb56e56227628">More...</a><br /></td></tr>
<tr class="separator:gab181cd27be267b76e7deb56e56227628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5689647a4f155fa357f32b1d0907c46"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaf5689647a4f155fa357f32b1d0907c46">AiNodeEntryGetNameAtString</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gaf5689647a4f155fa357f32b1d0907c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a> as an <a class="el" href="classAtString.html" title="Arnold String allows for fast string comparisons. ">AtString</a>.  <a href="#gaf5689647a4f155fa357f32b1d0907c46">More...</a><br /></td></tr>
<tr class="separator:gaf5689647a4f155fa357f32b1d0907c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f300beb73f6b1a19b1e2a0990ce417"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga01f300beb73f6b1a19b1e2a0990ce417">AiNodeEntryGetType</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga01f300beb73f6b1a19b1e2a0990ce417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>.  <a href="#ga01f300beb73f6b1a19b1e2a0990ce417">More...</a><br /></td></tr>
<tr class="separator:ga01f300beb73f6b1a19b1e2a0990ce417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6f413c31836af5688fd22d28b1bf1fd"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gab6f413c31836af5688fd22d28b1bf1fd">AiNodeEntryGetTypeName</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gab6f413c31836af5688fd22d28b1bf1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a> as a string.  <a href="#gab6f413c31836af5688fd22d28b1bf1fd">More...</a><br /></td></tr>
<tr class="separator:gab6f413c31836af5688fd22d28b1bf1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490b4adfc99ef9382fd31ac6faf1d9ed"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga490b4adfc99ef9382fd31ac6faf1d9ed">AiNodeEntryGetOutputType</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga490b4adfc99ef9382fd31ac6faf1d9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the output type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>.  <a href="#ga490b4adfc99ef9382fd31ac6faf1d9ed">More...</a><br /></td></tr>
<tr class="separator:ga490b4adfc99ef9382fd31ac6faf1d9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf656eea78fffbe088bcd3f53f000a199"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaf656eea78fffbe088bcd3f53f000a199">AiNodeEntryGetFilename</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gaf656eea78fffbe088bcd3f53f000a199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the filename (so/dll path) of an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>.  <a href="#gaf656eea78fffbe088bcd3f53f000a199">More...</a><br /></td></tr>
<tr class="separator:gaf656eea78fffbe088bcd3f53f000a199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab90a053df9c541c8d0a1bae3147cabe6"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gab90a053df9c541c8d0a1bae3147cabe6">AiNodeEntryGetVersion</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gab90a053df9c541c8d0a1bae3147cabe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version that this node was linked with.  <a href="#gab90a053df9c541c8d0a1bae3147cabe6">More...</a><br /></td></tr>
<tr class="separator:gab90a053df9c541c8d0a1bae3147cabe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b310c954bc66a54c299e9e98396a18a"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga9b310c954bc66a54c299e9e98396a18a">AiNodeEntryGetCount</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga9b310c954bc66a54c299e9e98396a18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of instances of a particular node.  <a href="#ga9b310c954bc66a54c299e9e98396a18a">More...</a><br /></td></tr>
<tr class="separator:ga9b310c954bc66a54c299e9e98396a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c5feea77852d4c4ca63ef5c9a06e299"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga3c5feea77852d4c4ca63ef5c9a06e299">AiNodeEntryGetNumParams</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga3c5feea77852d4c4ca63ef5c9a06e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of parameters of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>.  <a href="#ga3c5feea77852d4c4ca63ef5c9a06e299">More...</a><br /></td></tr>
<tr class="separator:ga3c5feea77852d4c4ca63ef5c9a06e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7f95ef4def897a63add88cd0587a9d"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaec7f95ef4def897a63add88cd0587a9d">AiNodeEntryGetParameter</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, int i)</td></tr>
<tr class="memdesc:gaec7f95ef4def897a63add88cd0587a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i'th parameter in an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>.  <a href="#gaec7f95ef4def897a63add88cd0587a9d">More...</a><br /></td></tr>
<tr class="separator:gaec7f95ef4def897a63add88cd0587a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b8e480586db25289bc89ab6a4cdc5a5"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEPRECATED AI_PURE const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga2b8e480586db25289bc89ab6a4cdc5a5">AiNodeEntryLookUpParameter</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, const char *param)</td></tr>
<tr class="memdesc:ga2b8e480586db25289bc89ab6a4cdc5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a parameter in a node entry from a name string.  <a href="#ga2b8e480586db25289bc89ab6a4cdc5a5">More...</a><br /></td></tr>
<tr class="separator:ga2b8e480586db25289bc89ab6a4cdc5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8b0591438ccf1e6d33141c34ff8f13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f8b0591438ccf1e6d33141c34ff8f13"></a>
AI_API AI_PURE const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeEntryLookUpParameterAtString</b> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga3f8b0591438ccf1e6d33141c34ff8f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80734ec2c7552ca29e925e051e6dfa08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga80734ec2c7552ca29e925e051e6dfa08"></a>
AI_PURE const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeEntryLookUpParameter</b> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="separator:ga80734ec2c7552ca29e925e051e6dfa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b5d817e07678b386679eb922aefbe5"><td class="memItemLeft" align="right" valign="top">AI_API AtParamIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaf1b5d817e07678b386679eb922aefbe5">AiNodeEntryGetParamIterator</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gaf1b5d817e07678b386679eb922aefbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new AtParamIterator for this node entry.  <a href="#gaf1b5d817e07678b386679eb922aefbe5">More...</a><br /></td></tr>
<tr class="separator:gaf1b5d817e07678b386679eb922aefbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac940e412ab70617c1b1003f8c8e5ddbd"><td class="memItemLeft" align="right" valign="top">AI_API AtMetaDataIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gac940e412ab70617c1b1003f8c8e5ddbd">AiNodeEntryGetMetaDataIterator</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, const char *param=<a class="el" href="group__ai__types.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr class="memdesc:gac940e412ab70617c1b1003f8c8e5ddbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new AtMetaDataIterator for this node entry.  <a href="#gac940e412ab70617c1b1003f8c8e5ddbd">More...</a><br /></td></tr>
<tr class="separator:gac940e412ab70617c1b1003f8c8e5ddbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8a644d9021043778edf64b9953f90e"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga6e8a644d9021043778edf64b9953f90e">AiNodeEntryInstall</a> (int type, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> output_type, const char *name, const char *filename, <a class="el" href="structAtNodeMethods.html">AtNodeMethods</a> *methods, const char *version)</td></tr>
<tr class="memdesc:ga6e8a644d9021043778edf64b9953f90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a new node in the system.  <a href="#ga6e8a644d9021043778edf64b9953f90e">More...</a><br /></td></tr>
<tr class="separator:ga6e8a644d9021043778edf64b9953f90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6abc6229eb77d0096810f4fee1befcd2"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga6abc6229eb77d0096810f4fee1befcd2">AiNodeEntryUninstall</a> (const char *name)</td></tr>
<tr class="memdesc:ga6abc6229eb77d0096810f4fee1befcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall a node from the system.  <a href="#ga6abc6229eb77d0096810f4fee1befcd2">More...</a><br /></td></tr>
<tr class="separator:ga6abc6229eb77d0096810f4fee1befcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
AtParamIterator Methods</h2></td></tr>
<tr class="memitem:ga305c25e73f44db3aec114b5af9e996b1"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga305c25e73f44db3aec114b5af9e996b1">AiParamIteratorDestroy</a> (AtParamIterator *iter)</td></tr>
<tr class="memdesc:ga305c25e73f44db3aec114b5af9e996b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a param iterator when it is no longer needed.  <a href="#ga305c25e73f44db3aec114b5af9e996b1">More...</a><br /></td></tr>
<tr class="separator:ga305c25e73f44db3aec114b5af9e996b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6311938c8b09934a8aaaaf78de06e064"><td class="memItemLeft" align="right" valign="top">AI_API const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga6311938c8b09934a8aaaaf78de06e064">AiParamIteratorGetNext</a> (AtParamIterator *iter)</td></tr>
<tr class="memdesc:ga6311938c8b09934a8aaaaf78de06e064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current param entry and points param iterator to the next one.  <a href="#ga6311938c8b09934a8aaaaf78de06e064">More...</a><br /></td></tr>
<tr class="separator:ga6311938c8b09934a8aaaaf78de06e064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d3ab8b20294363c89fd694596de145"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gac2d3ab8b20294363c89fd694596de145">AiParamIteratorFinished</a> (const AtParamIterator *iter)</td></tr>
<tr class="memdesc:gac2d3ab8b20294363c89fd694596de145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more parameters to iterate over.  <a href="#gac2d3ab8b20294363c89fd694596de145">More...</a><br /></td></tr>
<tr class="separator:gac2d3ab8b20294363c89fd694596de145"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
AtMetaDataIterator Methods</h2></td></tr>
<tr class="memitem:gafa165f4d801d854b7ef0bc757f96fe16"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gafa165f4d801d854b7ef0bc757f96fe16">AiMetaDataIteratorDestroy</a> (AtMetaDataIterator *iter)</td></tr>
<tr class="memdesc:gafa165f4d801d854b7ef0bc757f96fe16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a metadata iterator when it is no longer needed.  <a href="#gafa165f4d801d854b7ef0bc757f96fe16">More...</a><br /></td></tr>
<tr class="separator:gafa165f4d801d854b7ef0bc757f96fe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350ef9bc1dc56968b80ba2b49d9acae3"><td class="memItemLeft" align="right" valign="top">AI_API const <a class="el" href="structAtMetaDataEntry.html">AtMetaDataEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga350ef9bc1dc56968b80ba2b49d9acae3">AiMetaDataIteratorGetNext</a> (AtMetaDataIterator *iter)</td></tr>
<tr class="memdesc:ga350ef9bc1dc56968b80ba2b49d9acae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current metadata entry and points metadata iterator to the next one.  <a href="#ga350ef9bc1dc56968b80ba2b49d9acae3">More...</a><br /></td></tr>
<tr class="separator:ga350ef9bc1dc56968b80ba2b49d9acae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed3ad36805c2a2b850c9e776193a0de"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga2ed3ad36805c2a2b850c9e776193a0de">AiMetaDataIteratorFinished</a> (const AtMetaDataIterator *iter)</td></tr>
<tr class="memdesc:ga2ed3ad36805c2a2b850c9e776193a0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is no more metadata to iterate over.  <a href="#ga2ed3ad36805c2a2b850c9e776193a0de">More...</a><br /></td></tr>
<tr class="separator:ga2ed3ad36805c2a2b850c9e776193a0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>For a discussion of Arnold's object-oriented system of pluggable nodes, please refer to <a class="el" href="group__ai__nodes.html">AtNode API</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2c720b283ecc3d69edf18b9049269ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEPRECATED AI_PURE const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a>* AiNodeEntryLookUp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a node entry from a name string. </p>
<p>Search all installed node entries for a given node name. If found, return a pointer to the node entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>input node name (such as "lambert") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a> that matches the input name </dd></dl>

</div>
</div>
<a class="anchor" id="gab181cd27be267b76e7deb56e56227628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char* AiNodeEntryGetName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name string, or NULL if nentry is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5689647a4f155fa357f32b1d0907c46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="classAtString.html">AtString</a> AiNodeEntryGetNameAtString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a> as an <a class="el" href="classAtString.html" title="Arnold String allows for fast string comparisons. ">AtString</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classAtString.html" title="Arnold String allows for fast string comparisons. ">AtString</a> name string, or NULL <a class="el" href="classAtString.html" title="Arnold String allows for fast string comparisons. ">AtString</a> if nentry is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga01f300beb73f6b1a19b1e2a0990ce417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type of node (<code>AI_NODE_SHADER</code>, etc), or 0 if nentry is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gab6f413c31836af5688fd22d28b1bf1fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char* AiNodeEntryGetTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a> as a string. </p>
<p>For example, a node of type <code>AI_NODE_LIGHT</code> would return "light"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type string, or NULL if nentry is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga490b4adfc99ef9382fd31ac6faf1d9ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetOutputType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the output type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output type (<code>AI_TYPE_RGB</code>, etc) </dd></dl>

</div>
</div>
<a class="anchor" id="gaf656eea78fffbe088bcd3f53f000a199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char* AiNodeEntryGetFilename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the filename (so/dll path) of an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string with the path ot the dynamic library where this node was installed from, NULL if this is a built-in node </dd></dl>

</div>
</div>
<a class="anchor" id="gab90a053df9c541c8d0a1bae3147cabe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char* AiNodeEntryGetVersion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the version that this node was linked with. </p>
<p>There are restrictions as to what previously-compiled plug-in nodes can function with a given Arnold library. For example, a plug-in node compiled and linked with Arnold 3.1.x can't be loaded (installed) on Arnold 3.2.x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing the Arnold version that this node was linked with. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b310c954bc66a54c299e9e98396a18a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of instances of a particular node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of nodes of this type that have been created so far (for example, how many "sphere" nodes exist in memory), or 0 if nentry is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c5feea77852d4c4ca63ef5c9a06e299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetNumParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of parameters of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of parameters in the node, or 0 if nentry is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="gaec7f95ef4def897a63add88cd0587a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const AtParamEntry* AiNodeEntryGetParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the i'th parameter in an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
    <tr><td class="paramname">i</td><td>parameter index, in 0..num_params-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the i'th parameter entry in this node </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b8e480586db25289bc89ab6a4cdc5a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEPRECATED AI_PURE const AtParamEntry* AiNodeEntryLookUpParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a parameter in a node entry from a name string. </p>
<p>Searches the parameter entries of a given node looking for a parameter that matches the name string. If found, returns a pointer to the parameter entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
    <tr><td class="paramname">name</td><td>parameter name that we are looking for (such as "samples") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the AtParamEntry that matches the parameter name, or NULL if either nentry is NULL or the parameter is not found </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1b5d817e07678b386679eb922aefbe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtParamIterator* AiNodeEntryGetParamIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new AtParamIterator for this node entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>node entry whose parameters will be iterated over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over all built-in parameters on this node entry </dd></dl>

</div>
</div>
<a class="anchor" id="gac940e412ab70617c1b1003f8c8e5ddbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtMetaDataIterator* AiNodeEntryGetMetaDataIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new AtMetaDataIterator for this node entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>node entry whose metadata will be iterated over </td></tr>
    <tr><td class="paramname">param</td><td>selects a specific parameter to get its metadata or NULL for node metadata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over metadata on this node entry </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e8a644d9021043778edf64b9953f90e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeEntryInstall </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtNodeMethods.html">AtNodeMethods</a> *&#160;</td>
          <td class="paramname"><em>methods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a new node in the system. </p>
<p>An Arnold-based app can use this function to extend the renderer with custom types of nodes, such as new shaders or cameras. The user must provide the node type, name, and methods. Successive calls to <a class="el" href="group__ai__nodes.html#ga3f998aa34d354752af1e2493fad657c2" title="Create a fresh instantiation of a node. ">AiNode()</a> can create nodes of this type.</p>
<p>Examples: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AiNodeEntryInstall(AI_NODE_SHAPE, AI_TYPE_UNDEFINED, &quot;sphere&quot;, &quot;&lt;built-in&gt;&quot;, SphMethods, AI_VERSION);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AiNodeEntryInstall(AI_NODE_SHADER, AI_TYPE_FLOAT, &quot;fBm_noise&quot;, &quot;./shaders/fBm_noise.so&quot;, fBmMethods, AI_VERSION);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of node (<code>AI_NODE_CAMERA</code>, <code>AI_NODE_SHADER</code>, etc) </td></tr>
    <tr><td class="paramname">output_type</td><td>for shader nodes, which can link their output to the input of another shader, this is the output type (<code>AI_TYPE_RGB</code>, etc) </td></tr>
    <tr><td class="paramname">name</td><td>name string of the newly created node type </td></tr>
    <tr><td class="paramname">filename</td><td>string identifier that hints at how this node was created, usually the path of the dynamic library where it was loaded from but, in general, it should be set to whatever makes sense for the app that's installing the node </td></tr>
    <tr><td class="paramname">methods</td><td>pointer to the node methods </td></tr>
    <tr><td class="paramname">version</td><td>Arnold version string that this node is linked with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6abc6229eb77d0096810f4fee1befcd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeEntryUninstall </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninstall a node from the system. </p>
<p>Remove the node with the given name from the system. Successive calls to <a class="el" href="group__ai__nodes.html#ga3f998aa34d354752af1e2493fad657c2" title="Create a fresh instantiation of a node. ">AiNode()</a> using this node name will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the node to be removed from the system </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga305c25e73f44db3aec114b5af9e996b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiParamIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a param iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>param iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6311938c8b09934a8aaaaf78de06e064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const AtParamEntry* AiParamIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current param entry and points param iterator to the next one. </p>
<p>This function is designed to be used inside a loop, as illustrated by the following example, which prints all the built-in parameters of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtParamIterator *iter = AiNodeEntryGetParamIterator(nentry);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;while (!AiParamIteratorFinished(iter))</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   AtParamEntry *pentry = AiParamIteratorGetNext(iter);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   printf(&quot;%s\n&quot;, AiParamGetName(pentry));</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;AiParamIteratorDestroy(iter);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a param iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current param entry pointed by the iterator, or <code>NULL</code> if there are no more parameters to iterate over </dd></dl>

</div>
</div>
<a class="anchor" id="gac2d3ab8b20294363c89fd694596de145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiParamIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more parameters to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a param iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the param iterator has moved past the last parameter </dd></dl>

</div>
</div>
<a class="anchor" id="gafa165f4d801d854b7ef0bc757f96fe16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMetaDataIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtMetaDataIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a metadata iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>metadata iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga350ef9bc1dc56968b80ba2b49d9acae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const <a class="el" href="structAtMetaDataEntry.html">AtMetaDataEntry</a>* AiMetaDataIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtMetaDataIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current metadata entry and points metadata iterator to the next one. </p>
<p>This function is designed to be used inside a loop, as illustrated by the following example, which prints all the metadata of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtMetaDataIterator *iter = AiNodeEntryGetMetaDataIterator(nentry);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;while (!AiMetaDataIteratorFinished(iter))</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   const AtMetaDataEntry *entry = AiMetaDataIteratorGetNext(iter);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   printf(&quot;%s\n&quot;, entry-&gt;name);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;AiMetaDataIteratorDestroy(iter);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a metadata iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current metadata entry pointed by the iterator, or <code>NULL</code> if there is no more metadata to iterate over </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ed3ad36805c2a2b850c9e776193a0de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiMetaDataIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtMetaDataIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there is no more metadata to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a metadata iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the metadata iterator has moved past the last entry </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2009-2016 Solid Angle SL &middot all rights reserved &middot <a href="http://www.solidangle.com"><font size=-2 color=#C9C9C9>www.solidangle.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
