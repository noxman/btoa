<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arnold 4.2.14.2 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Volume Plugin API</div>  </div>
</div><!--header-->
<div class="contents">

<p>This API is used to interact with custom volumes and formats at render time.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtVolumeData.html">AtVolumeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume data, as returned by <a class="el" href="group__ai__volumes.html#gacc9b10f81897f73f6639d766710a5d5d">AtVolumePluginCreateVolume</a>.  <a href="structAtVolumeData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtVolumePluginVtable.html">AtVolumePluginVtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin function table.  <a href="structAtVolumePluginVtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga106ca06f566d7378426f3689b3ca1a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga106ca06f566d7378426f3689b3ca1a03">volume_plugin_loader</a>&#160;&#160;&#160;<a class="el" href="group__ai__plugins.html#ga95e724cd6a8385c2cea8d7fddc3a5d28">AI_EXPORT_LIB</a> bool VolumePluginLoader(<a class="el" href="structAtVolumePluginVtable.html">AtVolumePluginVtable</a>* vtable)</td></tr>
<tr class="memdesc:ga106ca06f566d7378426f3689b3ca1a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy shortcut for writing volume plugins.  <a href="#ga106ca06f566d7378426f3689b3ca1a03">More...</a><br /></td></tr>
<tr class="separator:ga106ca06f566d7378426f3689b3ca1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabe6c3604458a81adbb9541116ec45d82"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gabe6c3604458a81adbb9541116ec45d82">AtVolumePluginInit</a>) (void **user_ptr)</td></tr>
<tr class="memdesc:gabe6c3604458a81adbb9541116ec45d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin init method.  <a href="#gabe6c3604458a81adbb9541116ec45d82">More...</a><br /></td></tr>
<tr class="separator:gabe6c3604458a81adbb9541116ec45d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfe24ebc98193d6456f5935ed90e9579"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gadfe24ebc98193d6456f5935ed90e9579">AtVolumePluginCleanup</a>) (void *user_ptr)</td></tr>
<tr class="memdesc:gadfe24ebc98193d6456f5935ed90e9579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin cleanup method.  <a href="#gadfe24ebc98193d6456f5935ed90e9579">More...</a><br /></td></tr>
<tr class="separator:gadfe24ebc98193d6456f5935ed90e9579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9b10f81897f73f6639d766710a5d5d"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gacc9b10f81897f73f6639d766710a5d5d">AtVolumePluginCreateVolume</a>) (void *user_ptr, const char *user_string, const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td></tr>
<tr class="memdesc:gacc9b10f81897f73f6639d766710a5d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin volume creation.  <a href="#gacc9b10f81897f73f6639d766710a5d5d">More...</a><br /></td></tr>
<tr class="separator:gacc9b10f81897f73f6639d766710a5d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a62e519527dee81b4b0e22d0b8d9593"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga4a62e519527dee81b4b0e22d0b8d9593">AtVolumePluginUpdateVolume</a>) (void *user_ptr, const char *user_string, const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td></tr>
<tr class="memdesc:ga4a62e519527dee81b4b0e22d0b8d9593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin volume update.  <a href="#ga4a62e519527dee81b4b0e22d0b8d9593">More...</a><br /></td></tr>
<tr class="separator:ga4a62e519527dee81b4b0e22d0b8d9593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ccd339ab12eeb595d317438fbf30a0"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gac5ccd339ab12eeb595d317438fbf30a0">AtVolumePluginCleanupVolume</a>) (void *user_ptr, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gac5ccd339ab12eeb595d317438fbf30a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin volume cleanup method.  <a href="#gac5ccd339ab12eeb595d317438fbf30a0">More...</a><br /></td></tr>
<tr class="separator:gac5ccd339ab12eeb595d317438fbf30a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b57eccc15e00ec258baf6bded00578"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gae8b57eccc15e00ec258baf6bded00578">AtVolumePluginSample</a>) (void *user_ptr, const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const <a class="el" href="classAtString.html">AtString</a> channel, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int interp, <a class="el" href="unionAtParamValue.html">AtParamValue</a> *value, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> *type)</td></tr>
<tr class="memdesc:gae8b57eccc15e00ec258baf6bded00578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin sample method.  <a href="#gae8b57eccc15e00ec258baf6bded00578">More...</a><br /></td></tr>
<tr class="separator:gae8b57eccc15e00ec258baf6bded00578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3faf6703c1fd04ead43f15bc4a5f48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a3faf6703c1fd04ead43f15bc4a5f48"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtVolumePluginSampleDeprecated</b>) (void *user_ptr, const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const char *channel, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int interp, <a class="el" href="unionAtParamValue.html">AtParamValue</a> *value, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> *type)</td></tr>
<tr class="separator:ga7a3faf6703c1fd04ead43f15bc4a5f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15496348020553b2f4e0361100d37a31"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga15496348020553b2f4e0361100d37a31">AtVolumePluginRayExtents</a>) (void *user_ptr, const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const AtVolumeIntersectionInfo *info, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> tid, float time, const <a class="el" href="structAtPoint.html">AtPoint</a> *origin, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *direction, float t0, float t1)</td></tr>
<tr class="memdesc:ga15496348020553b2f4e0361100d37a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin method for submitting extents along a ray where there is data.  <a href="#ga15496348020553b2f4e0361100d37a31">More...</a><br /></td></tr>
<tr class="separator:ga15496348020553b2f4e0361100d37a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd979be744c4da0bfa20db92bbdfe17b"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#gacd979be744c4da0bfa20db92bbdfe17b">AtVolumePluginLoader</a>) (<a class="el" href="structAtVolumePluginVtable.html">AtVolumePluginVtable</a> *vtable)</td></tr>
<tr class="memdesc:gacd979be744c4da0bfa20db92bbdfe17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume plugin entry-point symbol.  <a href="#gacd979be744c4da0bfa20db92bbdfe17b">More...</a><br /></td></tr>
<tr class="separator:gacd979be744c4da0bfa20db92bbdfe17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga410fbbf47e5b9094293e6546a2f82f88"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> (const AtVolumeIntersectionInfo *info, float t0, float t1)</td></tr>
<tr class="memdesc:ga410fbbf47e5b9094293e6546a2f82f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a ray interval/extent for volume integration.  <a href="#ga410fbbf47e5b9094293e6546a2f82f88">More...</a><br /></td></tr>
<tr class="separator:ga410fbbf47e5b9094293e6546a2f82f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Volume interpolation quality</h2></td></tr>
<tr class="memitem:ga2fb44d2a905b83a4991d692b5c836d51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2fb44d2a905b83a4991d692b5c836d51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga2fb44d2a905b83a4991d692b5c836d51">AI_VOLUME_INTERP_CLOSEST</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2fb44d2a905b83a4991d692b5c836d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">closest data from the volume <br /></td></tr>
<tr class="separator:ga2fb44d2a905b83a4991d692b5c836d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0220a799d98f756e0daa4617233f35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2c0220a799d98f756e0daa4617233f35"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga2c0220a799d98f756e0daa4617233f35">AI_VOLUME_INTERP_TRILINEAR</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga2c0220a799d98f756e0daa4617233f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">trilinearly sampled volume <br /></td></tr>
<tr class="separator:ga2c0220a799d98f756e0daa4617233f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbde2a4d76bfc4d5acaf9b6bca28d4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4bbde2a4d76bfc4d5acaf9b6bca28d4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__volumes.html#ga4bbde2a4d76bfc4d5acaf9b6bca28d4c">AI_VOLUME_INTERP_TRICUBIC</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga4bbde2a4d76bfc4d5acaf9b6bca28d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tricubicly sampled volume <br /></td></tr>
<tr class="separator:ga4bbde2a4d76bfc4d5acaf9b6bca28d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This API is used to interact with custom volumes and formats at render time. </p>
<p>This is accomplished by providing the renderer some callback functions which are called as needed (when the volume is hit by a ray). Volume plugins are intended to provide tight ray intervals surrounding actual volumetric data, as well as sampling methods for sampling data channels from volumes.</p>
<p>Note that volume plugins have a thread-locked part: init and cleanup, while the rest of the callbacks may be called concurrently from multiple threads. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga106ca06f566d7378426f3689b3ca1a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define volume_plugin_loader&#160;&#160;&#160;<a class="el" href="group__ai__plugins.html#ga95e724cd6a8385c2cea8d7fddc3a5d28">AI_EXPORT_LIB</a> bool VolumePluginLoader(<a class="el" href="structAtVolumePluginVtable.html">AtVolumePluginVtable</a>* vtable)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handy shortcut for writing volume plugins. </p>
<p>This is a shorter, alternate way to declare the <a class="el" href="group__ai__volumes.html#gacd979be744c4da0bfa20db92bbdfe17b">AtVolumePluginLoader</a> symbol. Here is an example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;volume_plugin_loader </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   vtable-&gt;Init           = MyInit;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   vtable-&gt;Cleanup        = MyCleanup;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   vtable-&gt;CreateVolume   = MyCreateVolume;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   vtable-&gt;UpdateVolume   = MyUpdateVolume;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   vtable-&gt;CleanupVolume  = MyCleanupVolume;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   vtable-&gt;Sample         = MySample;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   vtable-&gt;RayExtents     = MyRayExtents;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   strcpy(vtable-&gt;version, AI_VERSION);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   return true;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gabe6c3604458a81adbb9541116ec45d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumePluginInit) (void **user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin init method. </p>
<p>This method will be called first and should perform any initialization required by this volume type. This might involve initializing an external volume format API, for example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">user_ptr</td><td>This is a general-purpose, user-supplied data pointer that Arnold will pass along to the other volume plugin methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="gadfe24ebc98193d6456f5935ed90e9579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumePluginCleanup) (void *user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin cleanup method. </p>
<p>This method will be called last and should perform any cleanup required by your volume plugin. Make sure you release any memory you allocated that is no longer needed by Arnold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__volumes.html#gabe6c3604458a81adbb9541116ec45d82">AtVolumePluginInit</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="gacc9b10f81897f73f6639d766710a5d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumePluginCreateVolume) (void *user_ptr, const char *user_string, const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin volume creation. </p>
<p>This method will be called for each volume node before usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__volumes.html#gabe6c3604458a81adbb9541116ec45d82">AtVolumePluginInit</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">user_string</td><td>User configuration string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>Owner node where the volume was requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Volume data with all fields to be set by the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if volume creation succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a62e519527dee81b4b0e22d0b8d9593"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumePluginUpdateVolume) (void *user_ptr, const char *user_string, const <a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin volume update. </p>
<p>This optional method will be called for each volume node before each render pass or scene change, so that the volume can be update accordingly. If not provided, the volume will be destroyed and recreated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__volumes.html#gabe6c3604458a81adbb9541116ec45d82">AtVolumePluginInit</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">user_string</td><td>User configuration string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>Owner node where the volume was requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Volume data with all fields to be set by the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if volume data was modified </dd></dl>

</div>
</div>
<a class="anchor" id="gac5ccd339ab12eeb595d317438fbf30a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumePluginCleanupVolume) (void *user_ptr, <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const <a class="el" href="structAtNode.html">AtNode</a> *node)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin volume cleanup method. </p>
<p>This method will be called once for each volume that was created by a call to <a class="el" href="group__ai__volumes.html#gacc9b10f81897f73f6639d766710a5d5d">AtVolumePluginCreateVolume</a> to allow a chance to clean up any private data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__volumes.html#gabe6c3604458a81adbb9541116ec45d82">AtVolumePluginInit</a> </td></tr>
    <tr><td class="paramname">data</td><td>Volume data returned from <a class="el" href="group__ai__volumes.html#gacc9b10f81897f73f6639d766710a5d5d">AtVolumePluginCreateVolume</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="gae8b57eccc15e00ec258baf6bded00578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumePluginSample) (void *user_ptr, const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const <a class="el" href="classAtString.html">AtString</a> channel, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int interp, <a class="el" href="unionAtParamValue.html">AtParamValue</a> *value, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> *type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin sample method. </p>
<p>This method will be called concurrently to sample data from a given channel with the specified interpolation. Implementors should use sg-&gt;Po as the sampling position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__volumes.html#gabe6c3604458a81adbb9541116ec45d82">AtVolumePluginInit</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Volume data returned from <a class="el" href="group__ai__volumes.html#gacc9b10f81897f73f6639d766710a5d5d">AtVolumePluginCreateVolume</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">channel</td><td>Data channel name from the volume </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>Shader globals for the sampling context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">interp</td><td>Volume interpolation quality, one of <code>AI_VOLUME_INTERP_*</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Resulting sampled value, matching the type output in out_type </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>Resulting value type, one of <code>AI_TYPE_FLOAT</code>, <code>AI_TYPE_POINT</code>, <code>AI_TYPE_POINT2</code>, <code>AI_TYPE_RGB</code>, <code>AI_TYPE_RGBA</code>, or <code>AI_TYPE_VECTOR</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="ga15496348020553b2f4e0361100d37a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* AtVolumePluginRayExtents) (void *user_ptr, const <a class="el" href="structAtVolumeData.html">AtVolumeData</a> *data, const AtVolumeIntersectionInfo *info, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> tid, float time, const <a class="el" href="structAtPoint.html">AtPoint</a> *origin, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *direction, float t0, float t1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin method for submitting extents along a ray where there is data. </p>
<p>For each ray interval where there is volumetric potentially to be integrated this callback should call <a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> to submit the extent along the ray.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any ray extents submitted that overlap will have the shaders run more than once for each extent. If shaders should only be run once, then those extents should be merged and submitted just once to <a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__volumes.html#gabe6c3604458a81adbb9541116ec45d82">AtVolumePluginInit</a> </td></tr>
    <tr><td class="paramname">data</td><td>Volume data returned from <a class="el" href="group__ai__volumes.html#gacc9b10f81897f73f6639d766710a5d5d">AtVolumePluginCreateVolume</a> </td></tr>
    <tr><td class="paramname">info</td><td>Opaque ptr to intersection info passed to <a class="el" href="group__ai__volumes.html#ga410fbbf47e5b9094293e6546a2f82f88">AiVolumeAddIntersection</a> </td></tr>
    <tr><td class="paramname">tid</td><td>Current thread ID, use for thread-local access as needed </td></tr>
    <tr><td class="paramname">time</td><td>Time at which the volume is being sampled (for motion blur) </td></tr>
    <tr><td class="paramname">origin</td><td>Ray origin in object space </td></tr>
    <tr><td class="paramname">direction</td><td>Ray direction, normalized and in object space </td></tr>
    <tr><td class="paramname">t0</td><td>Start of the master ray interval in which to check for extents </td></tr>
    <tr><td class="paramname">t1</td><td>End of the master ray interval in which to check for extents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacd979be744c4da0bfa20db92bbdfe17b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtVolumePluginLoader) (<a class="el" href="structAtVolumePluginVtable.html">AtVolumePluginVtable</a> *vtable)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume plugin entry-point symbol. </p>
<p>Volume plugin DSOs must define a symbol named "VolumePluginLoader" of this type. It should fill in the fields of a <a class="el" href="structAtVolumePluginVtable.html">AtVolumePluginVtable</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vtable</td><td>List of volume plugin methods to be supplied by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga410fbbf47e5b9094293e6546a2f82f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiVolumeAddIntersection </td>
          <td>(</td>
          <td class="paramtype">const AtVolumeIntersectionInfo *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a ray interval/extent for volume integration. </p>
<p>This is only useable from <a class="el" href="group__ai__volumes.html#ga15496348020553b2f4e0361100d37a31">AtVolumePluginRayExtents</a>, where a valid pointer to AtVolumeIntersectionInfo is provided. This call may be made as many times as necessary to tightly describe where the volume data exists along the ray, but note that if overlapping extents are submitted they will be independently integrated (and shaded more than once in the overlapping areas). If you need them integrated just once, you must merge your extents first before passing them here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>Private intersection information </td></tr>
    <tr><td class="paramname">t0</td><td>Beginning of ray extent </td></tr>
    <tr><td class="paramname">t1</td><td>End of ray extent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2009-2016 Solid Angle SL &middot all rights reserved &middot <a href="http://www.solidangle.com"><font size=-2 color=#C9C9C9>www.solidangle.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
