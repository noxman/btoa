<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arnold 4.2.14.2 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shader Utility API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Coordinate Transformations</h2></td></tr>
<tr class="memitem:gaf94cdbe877ec107f1b36a8c2e8986def"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf94cdbe877ec107f1b36a8c2e8986def"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaf94cdbe877ec107f1b36a8c2e8986def">AI_WORLD_TO_OBJECT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf94cdbe877ec107f1b36a8c2e8986def"><td class="mdescLeft">&#160;</td><td class="mdescRight">World-to-object coordinate transformation. <br /></td></tr>
<tr class="separator:gaf94cdbe877ec107f1b36a8c2e8986def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63bd87c3f5d74f268f346fb3b4f8a93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad63bd87c3f5d74f268f346fb3b4f8a93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gad63bd87c3f5d74f268f346fb3b4f8a93">AI_OBJECT_TO_WORLD</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gad63bd87c3f5d74f268f346fb3b4f8a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object-to-world coordinate transformation. <br /></td></tr>
<tr class="separator:gad63bd87c3f5d74f268f346fb3b4f8a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Wireframe Types</h2></td></tr>
<tr class="memitem:ga3e95eeae8b6cab6a1baac3c7fc41819e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e95eeae8b6cab6a1baac3c7fc41819e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga3e95eeae8b6cab6a1baac3c7fc41819e">AI_WIREFRAME_TRIANGLES</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga3e95eeae8b6cab6a1baac3c7fc41819e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tessellated triangles. <br /></td></tr>
<tr class="separator:ga3e95eeae8b6cab6a1baac3c7fc41819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169b8934e524b156cd9a47ef76ccd1a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga169b8934e524b156cd9a47ef76ccd1a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga169b8934e524b156cd9a47ef76ccd1a9">AI_WIREFRAME_POLYGONS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga169b8934e524b156cd9a47ef76ccd1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tessellated polygons. <br /></td></tr>
<tr class="separator:ga169b8934e524b156cd9a47ef76ccd1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51055e5eee9e21546beef9641f5d5bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad51055e5eee9e21546beef9641f5d5bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gad51055e5eee9e21546beef9641f5d5bd">AI_WIREFRAME_PATCHES</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gad51055e5eee9e21546beef9641f5d5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patches before subdivision. <br /></td></tr>
<tr class="separator:gad51055e5eee9e21546beef9641f5d5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Lighting Functions</h2></td></tr>
<tr class="memitem:ga0a23258c5ec45bf5dc80eb2e27ed57bd"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga0a23258c5ec45bf5dc80eb2e27ed57bd">AiOcclusion</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *Ng, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float mint, float maxt, float spread, float falloff, const <a class="el" href="group__ai__sampler.html#ga020c82e219b20c68a9f17662743a1999">AtSampler</a> *sampler, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *Nbent)</td></tr>
<tr class="memdesc:ga0a23258c5ec45bf5dc80eb2e27ed57bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ambient occlusion at a shading point.  <a href="#ga0a23258c5ec45bf5dc80eb2e27ed57bd">More...</a><br /></td></tr>
<tr class="separator:ga0a23258c5ec45bf5dc80eb2e27ed57bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga377be3fd88f8775fe34e1210e5747217"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga377be3fd88f8775fe34e1210e5747217">AiSelfOcclusion</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *Ng, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float mint, float maxt, float spread, float falloff, const <a class="el" href="group__ai__sampler.html#ga020c82e219b20c68a9f17662743a1999">AtSampler</a> *sampler, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *Nbent)</td></tr>
<tr class="memdesc:ga377be3fd88f8775fe34e1210e5747217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ambient occlusion at a shading point, only considering the same object.  <a href="#ga377be3fd88f8775fe34e1210e5747217">More...</a><br /></td></tr>
<tr class="separator:ga377be3fd88f8775fe34e1210e5747217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb00fbeacf7d92cfe3c9e91aae2388ae"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaeb00fbeacf7d92cfe3c9e91aae2388ae">AiDirectDiffuse</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gaeb00fbeacf7d92cfe3c9e91aae2388ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direct-lighting component of the irradiance at a shading point.  <a href="#gaeb00fbeacf7d92cfe3c9e91aae2388ae">More...</a><br /></td></tr>
<tr class="separator:gaeb00fbeacf7d92cfe3c9e91aae2388ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cff5789ff61f81ed2ff2027b3bbc894"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga5cff5789ff61f81ed2ff2027b3bbc894">AiHairDirectDiffuseCache</a> (const struct <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga5cff5789ff61f81ed2ff2027b3bbc894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the direct irradiance interpolated from the hair diffuse cache.  <a href="#ga5cff5789ff61f81ed2ff2027b3bbc894">More...</a><br /></td></tr>
<tr class="separator:ga5cff5789ff61f81ed2ff2027b3bbc894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae83f1d39c879a843156e990186bb237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaae83f1d39c879a843156e990186bb237">AiIndirectDiffuse</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight)</td></tr>
<tr class="memdesc:gaae83f1d39c879a843156e990186bb237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indirect-lighting component of the irradiance at a shading point.  <a href="#gaae83f1d39c879a843156e990186bb237">More...</a><br /></td></tr>
<tr class="separator:gaae83f1d39c879a843156e990186bb237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665643deecf3afbb7162a66b82d5d2fe"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga665643deecf3afbb7162a66b82d5d2fe">AiReflect</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *I, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *R)</td></tr>
<tr class="memdesc:ga665643deecf3afbb7162a66b82d5d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specular direction R from incident direction I and normal N.  <a href="#ga665643deecf3afbb7162a66b82d5d2fe">More...</a><br /></td></tr>
<tr class="separator:ga665643deecf3afbb7162a66b82d5d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7fbfbf4514c3890a9c770e5fb8a3c2a"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaf7fbfbf4514c3890a9c770e5fb8a3c2a">AiReflectSafe</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *I, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *Ng, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *R)</td></tr>
<tr class="memdesc:gaf7fbfbf4514c3890a9c770e5fb8a3c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specular direction R from incident direction I and normal N.  <a href="#gaf7fbfbf4514c3890a9c770e5fb8a3c2a">More...</a><br /></td></tr>
<tr class="separator:gaf7fbfbf4514c3890a9c770e5fb8a3c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1adb6af67d862174c22c515d741057"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gace1adb6af67d862174c22c515d741057">AiRefract</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *I, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *T, float n1, float n2)</td></tr>
<tr class="memdesc:gace1adb6af67d862174c22c515d741057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns transmitted direction T from incident direction I and normal N.  <a href="#gace1adb6af67d862174c22c515d741057">More...</a><br /></td></tr>
<tr class="separator:gace1adb6af67d862174c22c515d741057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2ff6fe41e3e0d7aaf7a68357b90887"><td class="memItemLeft" align="right" valign="top">AI_API AI_CONST float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaef2ff6fe41e3e0d7aaf7a68357b90887">AiFresnelWeight</a> (<a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> N, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> Rd, float Krn)</td></tr>
<tr class="memdesc:gaef2ff6fe41e3e0d7aaf7a68357b90887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors.  <a href="#gaef2ff6fe41e3e0d7aaf7a68357b90887">More...</a><br /></td></tr>
<tr class="separator:gaef2ff6fe41e3e0d7aaf7a68357b90887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58df03bcf1db5c057e9d3d0d035200ff"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga58df03bcf1db5c057e9d3d0d035200ff">AiFresnelWeightRGB</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *Rd, const <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> *Krn, <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> *Kf)</td></tr>
<tr class="memdesc:ga58df03bcf1db5c057e9d3d0d035200ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized version of <a class="el" href="group__ai__shader__util.html#gaef2ff6fe41e3e0d7aaf7a68357b90887" title="Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors...">AiFresnelWeight()</a> for RGB reflectance.  <a href="#ga58df03bcf1db5c057e9d3d0d035200ff">More...</a><br /></td></tr>
<tr class="separator:ga58df03bcf1db5c057e9d3d0d035200ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ef7d7e0d1a0e773ec7be2561c093fa"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga57ef7d7e0d1a0e773ec7be2561c093fa">AiFaceForward</a> (<a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> I)</td></tr>
<tr class="memdesc:ga57ef7d7e0d1a0e773ec7be2561c093fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a normal vector face forward with respect to a given vector.  <a href="#ga57ef7d7e0d1a0e773ec7be2561c093fa">More...</a><br /></td></tr>
<tr class="separator:ga57ef7d7e0d1a0e773ec7be2561c093fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc325ec47bbbe198329fdeadf118712"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga2bc325ec47bbbe198329fdeadf118712">AiBuildLocalFrameShirley</a> (<a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *u, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *v, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N)</td></tr>
<tr class="memdesc:ga2bc325ec47bbbe198329fdeadf118712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an orthonormal basis aligned with vector N (Shirley's method).  <a href="#ga2bc325ec47bbbe198329fdeadf118712">More...</a><br /></td></tr>
<tr class="separator:ga2bc325ec47bbbe198329fdeadf118712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6942fc6fd6c78b8360de068316f2231"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaa6942fc6fd6c78b8360de068316f2231">AiBuildLocalFramePolar</a> (<a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *u, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *v, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N)</td></tr>
<tr class="memdesc:gaa6942fc6fd6c78b8360de068316f2231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an orthonormal basis aligned with vector N (polar method).  <a href="#gaa6942fc6fd6c78b8360de068316f2231">More...</a><br /></td></tr>
<tr class="separator:gaa6942fc6fd6c78b8360de068316f2231"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Utility Helper Types</h2></td></tr>
<tr class="memitem:ga91ed48a428cd8774c8c39f4761448d07"><td class="memItemLeft" align="right" valign="top">typedef float(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga91ed48a428cd8774c8c39f4761448d07">AtFloatBumpEvaluator</a>) (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, void *data)</td></tr>
<tr class="memdesc:ga91ed48a428cd8774c8c39f4761448d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pointer points to float-based bump-mapping function for use by <a class="el" href="group__ai__shader__util.html#ga71a5ed58ed8dcf54e526a5be235f73c0" title="Computes and returns a normal based on the current shading point and the specified bump-function...">AiShaderGlobalsEvaluateBump()</a>.  <a href="#ga91ed48a428cd8774c8c39f4761448d07">More...</a><br /></td></tr>
<tr class="separator:ga91ed48a428cd8774c8c39f4761448d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Utility Functions</h2></td></tr>
<tr class="memitem:ga08b8a364dbb046070d5f739cf4d92f7a"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga08b8a364dbb046070d5f739cf4d92f7a">AiShaderGlobalsGetTriangle</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int key, <a class="el" href="structAtPoint.html">AtPoint</a> p[3])</td></tr>
<tr class="memdesc:ga08b8a364dbb046070d5f739cf4d92f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get triangle vertices at a given motion key.  <a href="#ga08b8a364dbb046070d5f739cf4d92f7a">More...</a><br /></td></tr>
<tr class="separator:ga08b8a364dbb046070d5f739cf4d92f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbe9f856c030b56833996c2b25e8c797"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gacbe9f856c030b56833996c2b25e8c797">AiShaderGlobalsGetVertexNormals</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int key, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> n[3])</td></tr>
<tr class="memdesc:gacbe9f856c030b56833996c2b25e8c797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get normal vectors for all triangle vertices.  <a href="#gacbe9f856c030b56833996c2b25e8c797">More...</a><br /></td></tr>
<tr class="separator:gacbe9f856c030b56833996c2b25e8c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaadf4448dc7bb8957426d1a6ae2a0c92"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaaadf4448dc7bb8957426d1a6ae2a0c92">AiShaderGlobalsGetVertexUVs</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="structAtPoint2.html">AtPoint2</a> uv[3])</td></tr>
<tr class="memdesc:gaaadf4448dc7bb8957426d1a6ae2a0c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UV coordinates for all triangle vertices.  <a href="#gaaadf4448dc7bb8957426d1a6ae2a0c92">More...</a><br /></td></tr>
<tr class="separator:gaaadf4448dc7bb8957426d1a6ae2a0c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5659ede084f168dbe27fedd4a57bad70"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="group__ai__types.html#ga5e008e3afa9393ab65d66796de249df9">AtUInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga5659ede084f168dbe27fedd4a57bad70">AiShaderGlobalsGetPolygon</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, int key, <a class="el" href="structAtPoint.html">AtPoint</a> *p)</td></tr>
<tr class="memdesc:ga5659ede084f168dbe27fedd4a57bad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get polygon vertices at a given motion key.  <a href="#ga5659ede084f168dbe27fedd4a57bad70">More...</a><br /></td></tr>
<tr class="separator:ga5659ede084f168dbe27fedd4a57bad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0747b59d48dd8d85ce863e186ab827a5"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga0747b59d48dd8d85ce863e186ab827a5">AiShaderGlobalsGetPositionAtTime</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float time, <a class="el" href="structAtPoint.html">AtPoint</a> *P, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *N, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *Ng, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *Ns)</td></tr>
<tr class="memdesc:ga0747b59d48dd8d85ce863e186ab827a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reproject the shading point to a different time.  <a href="#ga0747b59d48dd8d85ce863e186ab827a5">More...</a><br /></td></tr>
<tr class="separator:ga0747b59d48dd8d85ce863e186ab827a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c6d3832018298445a2d771760f3883"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtPoint2.html">AtPoint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaf4c6d3832018298445a2d771760f3883">AiShaderGlobalsGetPixelMotionVector</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float time0, float time1)</td></tr>
<tr class="memdesc:gaf4c6d3832018298445a2d771760f3883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute motion vector.  <a href="#gaf4c6d3832018298445a2d771760f3883">More...</a><br /></td></tr>
<tr class="separator:gaf4c6d3832018298445a2d771760f3883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d559c4e509744f650a33fb43d2e33d"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gab9d559c4e509744f650a33fb43d2e33d">AiShaderGlobalsGetBBoxLocal</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gab9d559c4e509744f650a33fb43d2e33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object-space bounds of the current object.  <a href="#gab9d559c4e509744f650a33fb43d2e33d">More...</a><br /></td></tr>
<tr class="separator:gab9d559c4e509744f650a33fb43d2e33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae317950ce946a0e301697bea55a43381"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gae317950ce946a0e301697bea55a43381">AiShaderGlobalsGetBBoxWorld</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gae317950ce946a0e301697bea55a43381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the world-space bounds of the current object.  <a href="#gae317950ce946a0e301697bea55a43381">More...</a><br /></td></tr>
<tr class="separator:gae317950ce946a0e301697bea55a43381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5290fa2cf4f86b16bd5cc130e1b95e77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5290fa2cf4f86b16bd5cc130e1b95e77"></a>
AI_API AI_PURE <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsTransformNormal</b> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> N, int space)</td></tr>
<tr class="separator:ga5290fa2cf4f86b16bd5cc130e1b95e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff4ebdb1995678be6c73c60c402eb73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ff4ebdb1995678be6c73c60c402eb73"></a>
AI_API AI_PURE <a class="el" href="structAtPoint.html">AtPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsTransformPoint</b> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="structAtPoint.html">AtPoint</a> P, int space)</td></tr>
<tr class="separator:ga0ff4ebdb1995678be6c73c60c402eb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92d6408ee6f6b46bf0e0b4255a4d495"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae92d6408ee6f6b46bf0e0b4255a4d495"></a>
AI_API AI_PURE <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsTransformVector</b> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> V, int space)</td></tr>
<tr class="separator:gae92d6408ee6f6b46bf0e0b4255a4d495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16d08558e27152cb03e91fa009168d39"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEPRECATED void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga16d08558e27152cb03e91fa009168d39">AiShaderGlobalsSetTraceSet</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const char *set, bool inclusive)</td></tr>
<tr class="memdesc:ga16d08558e27152cb03e91fa009168d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a trace-set string and assigns it to the shader globals.  <a href="#ga16d08558e27152cb03e91fa009168d39">More...</a><br /></td></tr>
<tr class="separator:ga16d08558e27152cb03e91fa009168d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc4e79ffa4eeaafe041b6de7d042f88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1bc4e79ffa4eeaafe041b6de7d042f88"></a>
AI_API void&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsSetTraceSetAtString</b> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="classAtString.html">AtString</a> set, bool inclusive)</td></tr>
<tr class="separator:ga1bc4e79ffa4eeaafe041b6de7d042f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0c36af5dde85f66b448f72f3dc04c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb0c36af5dde85f66b448f72f3dc04c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>AiShaderGlobalsSetTraceSet</b> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="classAtString.html">AtString</a> set, bool inclusive)</td></tr>
<tr class="separator:gaeb0c36af5dde85f66b448f72f3dc04c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga127a2210ba0cbde40e1d22b496a4fe04"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga127a2210ba0cbde40e1d22b496a4fe04">AiShaderGlobalsUnsetTraceSet</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga127a2210ba0cbde40e1d22b496a4fe04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the trace-set for this shader globals.  <a href="#ga127a2210ba0cbde40e1d22b496a4fe04">More...</a><br /></td></tr>
<tr class="separator:ga127a2210ba0cbde40e1d22b496a4fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2bcfd0e80384d9f7cbd456b9e985bb1"><td class="memItemLeft" align="right" valign="top">AI_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaf2bcfd0e80384d9f7cbd456b9e985bb1">AiShaderGlobalsQuickAlloc</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="group__ai__types.html#ga5e008e3afa9393ab65d66796de249df9">AtUInt32</a> size)</td></tr>
<tr class="memdesc:gaf2bcfd0e80384d9f7cbd456b9e985bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates temporary memory for this ray-tree.  <a href="#gaf2bcfd0e80384d9f7cbd456b9e985bb1">More...</a><br /></td></tr>
<tr class="separator:gaf2bcfd0e80384d9f7cbd456b9e985bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a5ed58ed8dcf54e526a5be235f73c0"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga71a5ed58ed8dcf54e526a5be235f73c0">AiShaderGlobalsEvaluateBump</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="group__ai__shader__util.html#ga91ed48a428cd8774c8c39f4761448d07">AtFloatBumpEvaluator</a> bump_func, void *data)</td></tr>
<tr class="memdesc:ga71a5ed58ed8dcf54e526a5be235f73c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns a normal based on the current shading point and the specified bump-function.  <a href="#ga71a5ed58ed8dcf54e526a5be235f73c0">More...</a><br /></td></tr>
<tr class="separator:ga71a5ed58ed8dcf54e526a5be235f73c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841ba9e47e2f519902c578bf1b088bb9"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga841ba9e47e2f519902c578bf1b088bb9">AiShaderGlobalsApplyOpacity</a> (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="structAtRGB.html">AtRGB</a> opacity)</td></tr>
<tr class="memdesc:ga841ba9e47e2f519902c578bf1b088bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs some optimizations given the current opacity and shader globals which allow for increased performance.  <a href="#ga841ba9e47e2f519902c578bf1b088bb9">More...</a><br /></td></tr>
<tr class="separator:ga841ba9e47e2f519902c578bf1b088bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4eb45323afd6c37512549c0158bb175"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gad4eb45323afd6c37512549c0158bb175">AiShaderGlobalsEdgeLength</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gad4eb45323afd6c37512549c0158bb175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum (for now) edge length of a given polygon.  <a href="#gad4eb45323afd6c37512549c0158bb175">More...</a><br /></td></tr>
<tr class="separator:gad4eb45323afd6c37512549c0158bb175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da1e065672b2cd322ca2cc7b9f4ae71"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga3da1e065672b2cd322ca2cc7b9f4ae71">AiWireframe</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, float line_width, bool raster_space, int edge_type)</td></tr>
<tr class="memdesc:ga3da1e065672b2cd322ca2cc7b9f4ae71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes wireframe shading for a mesh.  <a href="#ga3da1e065672b2cd322ca2cc7b9f4ae71">More...</a><br /></td></tr>
<tr class="separator:ga3da1e065672b2cd322ca2cc7b9f4ae71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e7aa4ccd02c52c0c6feaa275dfc2c5"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga99e7aa4ccd02c52c0c6feaa275dfc2c5">AiShaderGlobalsIsObjectMatte</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga99e7aa4ccd02c52c0c6feaa275dfc2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the matte setting for the current object.  <a href="#ga99e7aa4ccd02c52c0c6feaa275dfc2c5">More...</a><br /></td></tr>
<tr class="separator:ga99e7aa4ccd02c52c0c6feaa275dfc2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff74f6c5c15cb865ade849e8aba06c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gafff74f6c5c15cb865ade849e8aba06c9">AiFaceViewer</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> &amp;n)</td></tr>
<tr class="memdesc:gafff74f6c5c15cb865ade849e8aba06c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the surface normal face the viewer.  <a href="#gafff74f6c5c15cb865ade849e8aba06c9">More...</a><br /></td></tr>
<tr class="separator:gafff74f6c5c15cb865ade849e8aba06c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Camera Information</h2></td></tr>
<tr class="memitem:gad42f91c8954bb803b6fd37c6590b2114"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114">AiCameraGetShutterStart</a> ()</td></tr>
<tr class="memdesc:gad42f91c8954bb803b6fd37c6590b2114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch camera shutter start.  <a href="#gad42f91c8954bb803b6fd37c6590b2114">More...</a><br /></td></tr>
<tr class="separator:gad42f91c8954bb803b6fd37c6590b2114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca3cda2dcbc6433aebb3a03e23e0e2b"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gadca3cda2dcbc6433aebb3a03e23e0e2b">AiCameraGetShutterEnd</a> ()</td></tr>
<tr class="memdesc:gadca3cda2dcbc6433aebb3a03e23e0e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch camera shutter end.  <a href="#gadca3cda2dcbc6433aebb3a03e23e0e2b">More...</a><br /></td></tr>
<tr class="separator:gadca3cda2dcbc6433aebb3a03e23e0e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e587584328a4509137500006cf0323f"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga8e587584328a4509137500006cf0323f">AiCameraToWorldMatrix</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, float time, <a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a> out)</td></tr>
<tr class="memdesc:ga8e587584328a4509137500006cf0323f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes camera to world matrix.  <a href="#ga8e587584328a4509137500006cf0323f">More...</a><br /></td></tr>
<tr class="separator:ga8e587584328a4509137500006cf0323f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga626f41ad0344afb06924886f243fd119"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga626f41ad0344afb06924886f243fd119">AiWorldToCameraMatrix</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, float time, <a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a> out)</td></tr>
<tr class="memdesc:ga626f41ad0344afb06924886f243fd119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes world to camera matrix.  <a href="#ga626f41ad0344afb06924886f243fd119">More...</a><br /></td></tr>
<tr class="separator:ga626f41ad0344afb06924886f243fd119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b488a6784866ddac341b74f0ff9ad2"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaa8b488a6784866ddac341b74f0ff9ad2">AiWorldToScreenMatrix</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node, float time, <a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a> out)</td></tr>
<tr class="memdesc:gaa8b488a6784866ddac341b74f0ff9ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes world to screen matrix.  <a href="#gaa8b488a6784866ddac341b74f0ff9ad2">More...</a><br /></td></tr>
<tr class="separator:gaa8b488a6784866ddac341b74f0ff9ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Environment Mappings</h2></td></tr>
<tr class="memitem:ga22ecdba64563716529b0469c02dec220"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga22ecdba64563716529b0469c02dec220">AiMappingMirroredBall</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, float *u, float *v)</td></tr>
<tr class="memdesc:ga22ecdba64563716529b0469c02dec220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a world-space direction vector to texture coordinates (u,v) based on the mirrored-ball mapping.  <a href="#ga22ecdba64563716529b0469c02dec220">More...</a><br /></td></tr>
<tr class="separator:ga22ecdba64563716529b0469c02dec220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58be830148a466be59ee09803f67154"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gad58be830148a466be59ee09803f67154">AiMappingAngularMap</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, float *u, float *v)</td></tr>
<tr class="memdesc:gad58be830148a466be59ee09803f67154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a world-space direction vector to texture coordinates (u,v) based on an angular mapping.  <a href="#gad58be830148a466be59ee09803f67154">More...</a><br /></td></tr>
<tr class="separator:gad58be830148a466be59ee09803f67154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a54d8e31755fe9e1a2357df21cbf8bd"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga4a54d8e31755fe9e1a2357df21cbf8bd">AiMappingLatLong</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, float *u, float *v)</td></tr>
<tr class="memdesc:ga4a54d8e31755fe9e1a2357df21cbf8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a world-space direction vector to texture coordinates (u,v) based on the Latitude/Longitude mapping.  <a href="#ga4a54d8e31755fe9e1a2357df21cbf8bd">More...</a><br /></td></tr>
<tr class="separator:ga4a54d8e31755fe9e1a2357df21cbf8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc7f5585a55621b5f147328b962da7b"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga9fc7f5585a55621b5f147328b962da7b">AiMappingCubicMap</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, float *u, float *v)</td></tr>
<tr class="memdesc:ga9fc7f5585a55621b5f147328b962da7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a world-space direction vector to texture coordnates (u,v) based on a cubic mapping.  <a href="#ga9fc7f5585a55621b5f147328b962da7b">More...</a><br /></td></tr>
<tr class="separator:ga9fc7f5585a55621b5f147328b962da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Derivatives for Environment Mappings</h2></td></tr>
<tr class="memitem:gaf4fc493fc271d4513ee8580bf68ef763"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaf4fc493fc271d4513ee8580bf68ef763">AiMappingMirroredBallDerivs</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dDdx, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dDdy, float *u, float *v, float *dudx, float *dudy, float *dvdx, float *dvdy)</td></tr>
<tr class="memdesc:gaf4fc493fc271d4513ee8580bf68ef763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative version of <a class="el" href="group__ai__shader__util.html#ga22ecdba64563716529b0469c02dec220" title="Maps a world-space direction vector to texture coordinates (u,v) based on the mirrored-ball mapping...">AiMappingMirroredBall()</a>.  <a href="#gaf4fc493fc271d4513ee8580bf68ef763">More...</a><br /></td></tr>
<tr class="separator:gaf4fc493fc271d4513ee8580bf68ef763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f02494812af63a19e6f39c15536c87c"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#ga8f02494812af63a19e6f39c15536c87c">AiMappingAngularMapDerivs</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dDdx, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dDdy, float *u, float *v, float *dudx, float *dudy, float *dvdx, float *dvdy)</td></tr>
<tr class="memdesc:ga8f02494812af63a19e6f39c15536c87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative version of <a class="el" href="group__ai__shader__util.html#gad58be830148a466be59ee09803f67154" title="Maps a world-space direction vector to texture coordinates (u,v) based on an angular mapping...">AiMappingAngularMap()</a>.  <a href="#ga8f02494812af63a19e6f39c15536c87c">More...</a><br /></td></tr>
<tr class="separator:ga8f02494812af63a19e6f39c15536c87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca6167bab11dbf8c2f89d7cc7157cb9"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gaaca6167bab11dbf8c2f89d7cc7157cb9">AiMappingLatLongDerivs</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dDdx, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dDdy, float *u, float *v, float *dudx, float *dudy, float *dvdx, float *dvdy)</td></tr>
<tr class="memdesc:gaaca6167bab11dbf8c2f89d7cc7157cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative version of <a class="el" href="group__ai__shader__util.html#ga4a54d8e31755fe9e1a2357df21cbf8bd" title="Maps a world-space direction vector to texture coordinates (u,v) based on the Latitude/Longitude mapp...">AiMappingLatLong()</a>.  <a href="#gaaca6167bab11dbf8c2f89d7cc7157cb9">More...</a><br /></td></tr>
<tr class="separator:gaaca6167bab11dbf8c2f89d7cc7157cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b89253089de91e290266302dc96a9c"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__util.html#gae8b89253089de91e290266302dc96a9c">AiMappingCubicMapDerivs</a> (const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dDdx, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dDdy, float *u, float *v, float *dudx, float *dudy, float *dvdx, float *dvdy)</td></tr>
<tr class="memdesc:gae8b89253089de91e290266302dc96a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative version of <a class="el" href="group__ai__shader__util.html#ga9fc7f5585a55621b5f147328b962da7b" title="Maps a world-space direction vector to texture coordnates (u,v) based on a cubic mapping. ">AiMappingCubicMap()</a>.  <a href="#gae8b89253089de91e290266302dc96a9c">More...</a><br /></td></tr>
<tr class="separator:gae8b89253089de91e290266302dc96a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga91ed48a428cd8774c8c39f4761448d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float(* AtFloatBumpEvaluator) (<a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function pointer points to float-based bump-mapping function for use by <a class="el" href="group__ai__shader__util.html#ga71a5ed58ed8dcf54e526a5be235f73c0" title="Computes and returns a normal based on the current shading point and the specified bump-function...">AiShaderGlobalsEvaluateBump()</a>. </p>
<p>This function would return the displacement height for the given shading context. This function would be called three times (on three different shading contexts). The returned displacements would be used to generate a triangle from which a normal is calculated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>the current shading context </td></tr>
    <tr><td class="paramname">data</td><td>user-defined data pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bump/displacement height for the current shading context </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0a23258c5ec45bf5dc80eb2e27ed57bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> AiOcclusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Ng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>falloff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__sampler.html#ga020c82e219b20c68a9f17662743a1999">AtSampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Nbent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ambient occlusion at a shading point. </p>
<p>Computes an ambient occlusion lookup: fire a number of hemispherical rays, return the ratio of hits/rays and, optionally, also return the bent normal.</p>
<p>Note that if N is set to the mirror direction, you get <em>reflection occlusion</em>. In the extreme, if spread is set to 0, you get sharp <em>mirror occlusion</em>.</p>
<p>The geometric normal is used for detecting occlusion rays that penetrate into the surface, thus biasing the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>normal vector at the shading point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Ng</td><td>geometric normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the shader globals context where occlusion is evaluated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mint</td><td>minimum ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxt</td><td>maximum ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">spread</td><td>angular spread around the normal vector N, in the range [0,1], where 1 maps to 90 degrees (the full hemisphere) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">falloff</td><td>exponential falloff rate for the occlusion along the ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td>a two-dimensional <a class="el" href="group__ai__sampler.html#ga020c82e219b20c68a9f17662743a1999" title="Opaque data type for a sampler. ">AtSampler</a> object that holds the number of samples to take per evaluation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Nbent</td><td>if non-NULL, the average direction to non-occluded areas, or <em>bent normal</em>, will be stored here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ambient occlusion at {sg-&gt;P,N}</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__sampler.html#ga65e8c7100cc9defd57536537034d29db" title="Create a user sampler. ">AiSampler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga377be3fd88f8775fe34e1210e5747217"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> AiSelfOcclusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Ng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>spread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>falloff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__sampler.html#ga020c82e219b20c68a9f17662743a1999">AtSampler</a> *&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Nbent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ambient occlusion at a shading point, only considering the same object. </p>
<p>Computes an ambient occlusion lookup: fire a number of hemispherical rays, return the ratio of hits/rays and, optionally, also return the bent normal.</p>
<p>Note that if N is set to the mirror direction, you get <em>reflection occlusion</em>. In the extreme, if spread is set to 0, you get sharp <em>mirror occlusion</em>.</p>
<p>The geometric normal is used for detecting occlusion rays that penetrate into the surface, thus biasing the result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>normal vector at the shading point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Ng</td><td>geometric normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the shader globals context where occlusion is evaluated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mint</td><td>minimum ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxt</td><td>maximum ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">spread</td><td>angular spread around the normal vector N, in the range [0,1], where 1 maps to 90 degrees (the full hemisphere) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">falloff</td><td>exponential falloff rate for the occlusion along the ray distance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sampler</td><td>a two-dimensional <a class="el" href="group__ai__sampler.html#ga020c82e219b20c68a9f17662743a1999" title="Opaque data type for a sampler. ">AtSampler</a> object that holds the number of samples to take per evaluation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Nbent</td><td>if non-NULL, the average direction to non-occluded areas, or <em>bent normal</em>, will be stored here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ambient occlusion at {sg-&gt;P,N}</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__sampler.html#ga65e8c7100cc9defd57536537034d29db" title="Create a user sampler. ">AiSampler</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb00fbeacf7d92cfe3c9e91aae2388ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> AiDirectDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the direct-lighting component of the irradiance at a shading point. </p>
<p>Computes the irradiance coming directly from all light sources in the scene, at shading point sg-&gt;P with normal N.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>normal vector that defines the hemisphere of incoming radiance </td></tr>
    <tr><td class="paramname">sg</td><td>shader globals context where irradiance is evaluated at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>direct component of diffuse irradiance </dd></dl>

</div>
</div>
<a class="anchor" id="ga5cff5789ff61f81ed2ff2027b3bbc894"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> AiHairDirectDiffuseCache </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the direct irradiance interpolated from the hair diffuse cache. </p>
<p>This function stores direct diffuse lighting at hair vertices (technically: segment end points). The cache is filled on-demand on the first lookup.</p>
<p>This cache should only be used indirectly for GI rays, so the error introduced by interpolating within a segment is hopefully not too great (for directly viewed rays there is little benefit to using the diffuse cache because the specular highlights require their own light loop anyway).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>a shader globals context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an estimation of direct diffuse lighting at the shading point </dd></dl>

</div>
</div>
<a class="anchor" id="gaae83f1d39c879a843156e990186bb237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> AiIndirectDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the indirect-lighting component of the irradiance at a shading point. </p>
<p>Computes the indirect irradiance as an integral of the incident radiance over the hemisphere. The irradiance is computed at surface point sg-&gt;P.</p>
<p>This is usually called from shaders that need diffuse global illumination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>normal vector that defines the hemisphere of incoming radiance </td></tr>
    <tr><td class="paramname">sg</td><td>shader globals context where irradiance is evaluated at </td></tr>
    <tr><td class="paramname">weight</td><td>RGB weight applied to the result and used for Russian roulette termination for more efficient rendering with high GI depth </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>indirect component of diffuse irradiance </dd></dl>

</div>
</div>
<a class="anchor" id="ga665643deecf3afbb7162a66b82d5d2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiReflect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns specular direction R from incident direction I and normal N. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">I</td><td>incident direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>outgoing mirror direction with respect to N </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7fbfbf4514c3890a9c770e5fb8a3c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiReflectSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Ng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns specular direction R from incident direction I and normal N. </p>
<p>This function should be used for Phong-smoothed meshes instead of <a class="el" href="group__ai__shader__util.html#ga665643deecf3afbb7162a66b82d5d2fe" title="Returns specular direction R from incident direction I and normal N. ">AiReflect()</a>. It makes sure the reflected vector doesn't penetrate below the geometric normal, which happens when the smooth (interpolated) normal points away from the viewing direction near silhouettes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">I</td><td>incident direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Ng</td><td>surface normal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>outgoing mirror direction with respect to N </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gace1adb6af67d862174c22c515d741057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiRefract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns transmitted direction T from incident direction I and normal N. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">I</td><td>incident direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>outgoing transmitted direction with respect to N </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n1</td><td>index of refraction (IOR) of the medium the incident ray travels in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n2</td><td>index of refraction (IOR) of the medium the transmitted ray travels in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if total internal reflection (TIR) occurs and there is no transmission </dd></dl>

</div>
</div>
<a class="anchor" id="gaef2ff6fe41e3e0d7aaf7a68357b90887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_CONST float AiFresnelWeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Krn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors. </p>
<p>Uses Schlick's cos^5 approximation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramname">V</td><td>incident viewing direction </td></tr>
    <tr><td class="paramname">Krn</td><td>reflectance at normal incidence, derived from the dielectric's IOR </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reflectance value, in [0,1] </dd></dl>

</div>
</div>
<a class="anchor" id="ga58df03bcf1db5c057e9d3d0d035200ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiFresnelWeightRGB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> *&#160;</td>
          <td class="paramname"><em>Krn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__color.html#ga03caa98eaded3f2dd0527ed284656f04">AtColor</a> *&#160;</td>
          <td class="paramname"><em>Kf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimized version of <a class="el" href="group__ai__shader__util.html#gaef2ff6fe41e3e0d7aaf7a68357b90887" title="Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors...">AiFresnelWeight()</a> for RGB reflectance. </p>
<p>Using this function once avoids three calls to the scalar <a class="el" href="group__ai__shader__util.html#gaef2ff6fe41e3e0d7aaf7a68357b90887" title="Computes Fresnel reflectance at an air-dielectric interface for given normal and viewing vectors...">AiFresnelWeight()</a>, saving a few CPU cycles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">V</td><td>incident viewing direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Krn</td><td>reflectance at normal incidence, derived from the dielectric's IOR </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Kf</td><td>reflectance value, in [0,1]^3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga57ef7d7e0d1a0e773ec7be2561c093fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiFaceForward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a normal vector face forward with respect to a given vector. </p>
<p>Reverses vector N if needed, in order to make it face forward with respect to vector I.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">N</td><td>surface normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">I</td><td>incident direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2bc325ec47bbbe198329fdeadf118712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiBuildLocalFrameShirley </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an orthonormal basis aligned with vector N (Shirley's method). </p>
<p>This is Peter Shirley's method of building a local reference frame (U,V,W), where W = N. This method is discontinuous at the planes separating the spherical quadrants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>normalized U basis vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>normalized V basis vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>normalized vector that will serve as our W basis vector (usually this is a surface normal) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6942fc6fd6c78b8360de068316f2231"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiBuildLocalFramePolar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an orthonormal basis aligned with vector N (polar method). </p>
<p>Builds local reference frame (U,V,W), where W = N. Uses the parametric tangent vectors in polar coordinates. This is continuous all across the sphere but at the poles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>normalized U basis vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>normalized V basis vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">N</td><td>normalized vector that will serve as our W basis vector (usually this is a surface normal) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08b8a364dbb046070d5f739cf4d92f7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiShaderGlobalsGetTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtPoint.html">AtPoint</a>&#160;</td>
          <td class="paramname"><em>p</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get triangle vertices at a given motion key. </p>
<p>Return object-space triangle vertices at this shading context, at a given motion key. It is up to the caller to transform the vertices to world-space as needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>motion key to get the triangle at (if -1, vertices are interpolated at <code>sg-&gt;time</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>output array of triangle vertices in object-space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false if there is no triangle to get vertices from.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#ga5659ede084f168dbe27fedd4a57bad70" title="Get polygon vertices at a given motion key. ">AiShaderGlobalsGetPolygon</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacbe9f856c030b56833996c2b25e8c797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiShaderGlobalsGetVertexNormals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td>
          <td class="paramname"><em>n</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get normal vectors for all triangle vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>motion key to get the normals at (if -1, normals are interpolated at <code>sg-&gt;time</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>output array of triangle vertex normals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false if there is no triangle to get normals from or if the mesh doesn't have vertex normals, or during displacement.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not available during displacement.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#ga08b8a364dbb046070d5f739cf4d92f7a" title="Get triangle vertices at a given motion key. ">AiShaderGlobalsGetTriangle</a> </dd>
<dd>
<a class="el" href="group__ai__shader__util.html#gaaadf4448dc7bb8957426d1a6ae2a0c92" title="Get UV coordinates for all triangle vertices. ">AiShaderGlobalsGetVertexUVs</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaadf4448dc7bb8957426d1a6ae2a0c92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiShaderGlobalsGetVertexUVs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtPoint2.html">AtPoint2</a>&#160;</td>
          <td class="paramname"><em>uv</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UV coordinates for all triangle vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uv</td><td>output array of UV coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false if there is no triangle to get UVs from or if the mesh doesn't have UV coordinates.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#ga08b8a364dbb046070d5f739cf4d92f7a" title="Get triangle vertices at a given motion key. ">AiShaderGlobalsGetTriangle</a> </dd>
<dd>
<a class="el" href="group__ai__shader__util.html#gacbe9f856c030b56833996c2b25e8c797" title="Get normal vectors for all triangle vertices. ">AiShaderGlobalsGetVertexNormals</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5659ede084f168dbe27fedd4a57bad70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="group__ai__types.html#ga5e008e3afa9393ab65d66796de249df9">AtUInt32</a> AiShaderGlobalsGetPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtPoint.html">AtPoint</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get polygon vertices at a given motion key. </p>
<p>Return object-space polygon vertices at this shading context, at a given motion key. It is up to the caller to transform the vertices to world-space as needed.</p>
<p>Usage example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtUInt32 numvertices = AiShaderGlobalsGetPolygon(sg, key, NULL);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AtPoint* vertices    = (AtPoint*) AiShaderGlobalsQuickAlloc(sg, np * sizeof(AtPoint));</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AiShaderGlobalsGetPolygon(sg, key, vertices);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// do whatever process with the vertices</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>motion key to get the polygon at (if -1, vertices are interpolated at <code>sg-&gt;time</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>if non-null, it will be filled with polygon vertices in object-space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of polygon vertices, or 0 if there is no polygon in <code>sg</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#ga08b8a364dbb046070d5f739cf4d92f7a" title="Get triangle vertices at a given motion key. ">AiShaderGlobalsGetTriangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0747b59d48dd8d85ce863e186ab827a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiShaderGlobalsGetPositionAtTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtPoint.html">AtPoint</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Ng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>Ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reproject the shading point to a different time. </p>
<p>The function will take in a shader globals and output a new position, smooth and geometric normal. Note that the normals are optional, if any of them is not needed, you may pass <code>NULL</code> to avoid their calculation.</p>
<p>A typical use of this function is to reproject the shading point to time=0, so that the new point can be used to index into a user-created spatial data structure that was built at time=0 and thus has no support for motion-blur. For example, a static, octree-based irradiance cache.</p>
<dl class="section note"><dt>Note</dt><dd>Normals not available during displacement (will not be computed).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">time</td><td>time at which <code>sg-&gt;P</code> will be reprojected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>reprojected <code>sg-&gt;P</code> (required) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>reprojected <code>sg-&gt;N</code> (optional) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ng</td><td>reprojected <code>sg-&gt;Ng</code> (optional) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ns</td><td>reprojected <code>sg-&gt;Ns</code> (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf4c6d3832018298445a2d771760f3883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtPoint2.html">AtPoint2</a> AiShaderGlobalsGetPixelMotionVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute motion vector. </p>
<p>Measures the motion of the hit point in screen space during the given time interval. This can be used to implement screen space motion vector shaders.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals for current hit point </td></tr>
    <tr><td class="paramname">time0</td><td>time from which to start the vector </td></tr>
    <tr><td class="paramname">time1</td><td>time at which to stop the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>amount of motion in raster space (pixels) </dd></dl>

</div>
</div>
<a class="anchor" id="gab9d559c4e509744f650a33fb43d2e33d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a> AiShaderGlobalsGetBBoxLocal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the object-space bounds of the current object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object's bounding box in object-space </dd></dl>

</div>
</div>
<a class="anchor" id="gae317950ce946a0e301697bea55a43381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a> AiShaderGlobalsGetBBoxWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the world-space bounds of the current object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>a shader globals context of type <code>AI_CONTEXT_SURFACE</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the object's bounding box in world-space </dd></dl>

</div>
</div>
<a class="anchor" id="ga16d08558e27152cb03e91fa009168d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEPRECATED void AiShaderGlobalsSetTraceSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a trace-set string and assigns it to the shader globals. </p>
<p>Any ray created on the basis of this shader globals, will use this trace-set.</p>
<dl class="section warning"><dt>Warning</dt><dd>Since char* can be accessed <em>after</em> the assignment, it's possible (but unlikely) that someone will change the contents of the string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context where the trace-set will be stored </td></tr>
    <tr><td class="paramname">set</td><td>the trace-set string </td></tr>
    <tr><td class="paramname">inclusive</td><td>indicates if the trace-set is to be treated as an <em>inclusive</em> set, as opposed to an <em>exclusive</em> one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#ga127a2210ba0cbde40e1d22b496a4fe04" title="Resets the trace-set for this shader globals. ">AiShaderGlobalsUnsetTraceSet</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga127a2210ba0cbde40e1d22b496a4fe04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiShaderGlobalsUnsetTraceSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the trace-set for this shader globals. </p>
<p>Sets the trace-set to NULL which indicates that trace-sets are to be ignored. While the same behavior can be achieved by calling <a class="el" href="group__ai__shader__util.html#ga16d08558e27152cb03e91fa009168d39" title="Takes a trace-set string and assigns it to the shader globals. ">AiShaderGlobalsSetTraceSet()</a> and either passing in a NULL, or passing the name of a trace-set that doesn't exist and setting <code>inclusive</code> to false, it is both cleaner and more efficient to use this function instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context where the trace-set will be removed from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#ga16d08558e27152cb03e91fa009168d39" title="Takes a trace-set string and assigns it to the shader globals. ">AiShaderGlobalsSetTraceSet</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2bcfd0e80384d9f7cbd456b9e985bb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void* AiShaderGlobalsQuickAlloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__types.html#ga5e008e3afa9393ab65d66796de249df9">AtUInt32</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates temporary memory for this ray-tree. </p>
<p>This function returns a block of memory that will be accessible until the camera ray for this sample is done. The memory is allocated from an internal memory pool that is flushed after each sub-pixel sample. This is much faster than allocating memory via <code>malloc()</code> or AiMalloc(). This can be useful to exchange data of type pointer or string within shader networks or across rays by using message passing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>non-NULL shader globals context for the point being shaded </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a block of memory at least size bytes long or <code>NULL</code> if either parameter was <code>NULL</code> or 0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga71a5ed58ed8dcf54e526a5be235f73c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> AiShaderGlobalsEvaluateBump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__shader__util.html#ga91ed48a428cd8774c8c39f4761448d07">AtFloatBumpEvaluator</a>&#160;</td>
          <td class="paramname"><em>bump_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns a normal based on the current shading point and the specified bump-function. </p>
<p>This function will compute and return a perturbed normal based on the specified shading point and bump-mapping function. This function will create three new shader-globals contexts surrounding the shading point, and call the supplied bump-mapping function with the three new displaced shading contexts. Given a particular shading context, the bump-mapping function should return its associated displacement value (a float). The new normal is calculated based on a forward differencing of the the values returned by this bump-mapping function.</p>
<p>This function itself will not modify the incoming <a class="el" href="structAtShaderGlobals.html" title="Shader globals data structure. ">AtShaderGlobals</a>, but it is possible that the bump-mapping function itself, or those functions that it might call, will modify the incoming 'sg'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context for the point whose perturbed normal is being computed </td></tr>
    <tr><td class="paramname">bump_func</td><td>a bump-mapping function which returns a float-based displacement amount. This function will be executed three times with three different shading point contexts. </td></tr>
    <tr><td class="paramname">data</td><td>an opaque user-pointer which is passed on to the bump-mapping function in order to help pass on state information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a perturbed normal for the current shading point </dd></dl>

</div>
</div>
<a class="anchor" id="ga841ba9e47e2f519902c578bf1b088bb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiShaderGlobalsApplyOpacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs some optimizations given the current opacity and shader globals which allow for increased performance. </p>
<p>This function will compute an equivalent opacity to that given as the parameter. It will then set the sg-&gt;out_opacity value with the result of this computation.</p>
<p>The function will return a boolean result indicating whether or not the resulting opacity is totally transparent. If the value is true, the sg-&gt;out_opacity was set to AI_RGB_BLACK and the shader can perform an early exit since its result will not be visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context for the point whose opacity is being applied </td></tr>
    <tr><td class="paramname">opacity</td><td>opacity value upon which the optimizations are applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if completely transparent, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gad4eb45323afd6c37512549c0158bb175"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE float AiShaderGlobalsEdgeLength </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum (for now) edge length of a given polygon. </p>
<p>This is currently used by the heatmap code in the <code>utility</code> node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context at the shading point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum edge length of the polygon at <code>sg</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3da1e065672b2cd322ca2cc7b9f4ae71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE float AiWireframe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>line_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>raster_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes wireframe shading for a mesh. </p>
<p>Returns 0 when the current point is close to the triangle's edges and 1 otherwise. A fractional value may be returned in between for anti-aliasing purposes. This can be used to render the wireframe of a mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals context at the shading point </td></tr>
    <tr><td class="paramname">line_width</td><td>the size of the lines in either pixel-space or world-space </td></tr>
    <tr><td class="paramname">raster_space</td><td>if enabled, <code>line_width</code> works in pixel-space </td></tr>
    <tr><td class="paramname">edge_type</td><td>this value should be one of <code>AI_WIREFRAME_*</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a number in the range [0,1] </dd></dl>

</div>
</div>
<a class="anchor" id="ga99e7aa4ccd02c52c0c6feaa275dfc2c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiShaderGlobalsIsObjectMatte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the matte setting for the current object. </p>
<p>The matte setting when turned on will force the object to have an RGBA of zero. Surface shaders are not run when the object is both opaque and matte at the same time, and when it is not opaque the shaders will be run only to retrieve opacity for blending purposes.</p>
<dl class="section return"><dt>Returns</dt><dd>matte status for the object </dd></dl>

</div>
</div>
<a class="anchor" id="gafff74f6c5c15cb865ade849e8aba06c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AiFaceViewer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the surface normal face the viewer. </p>
<p>Reverses vector sg-&gt;N if needed, in order to make it face forward with respect to viewing vector sg-&gt;Rd (not necessarily a camera ray).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the current shading context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>viewer-facing normal vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad42f91c8954bb803b6fd37c6590b2114"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE float AiCameraGetShutterStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch camera shutter start. </p>
<dl class="section return"><dt>Returns</dt><dd>shutter start time </dd></dl>

</div>
</div>
<a class="anchor" id="gadca3cda2dcbc6433aebb3a03e23e0e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE float AiCameraGetShutterEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch camera shutter end. </p>
<p>This function correctly accounts for closed shutters and disabled motion blur.</p>
<dl class="section return"><dt>Returns</dt><dd>shutter end time </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e587584328a4509137500006cf0323f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiCameraToWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a>&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes camera to world matrix. </p>
<p>Computes the matrix that transforms between camera space and world space. Camera space is defined such that +x is right, +y is up and looks down -z. This function accounts for camera motion blur by calculating the matrix at the requested time. If you are not interested in motion information, you can use options.reference_time or <a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start. ">AiCameraGetShutterStart()</a> for time.</p>
<p>If the provided node is invalid, not a camera or otherwise not initialized this function will return the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>camera node to get matrix from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">time</td><td>absolute time at which to calculate the matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>this matrix will be filled with the camera to world matrix for the requested time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start. ">AiCameraGetShutterStart</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga626f41ad0344afb06924886f243fd119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiWorldToCameraMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a>&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes world to camera matrix. </p>
<p>Computes the matrix that transforms between world space and camera space. Camera space is defined such that +x is right, +y is up and looks down -z. This function accounts for camera motion blur by calculating the matrix at the requested time. If you are not interested in motion information, you can use options.reference_time or <a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start. ">AiCameraGetShutterStart()</a> for time.</p>
<p>If the provided node is invalid, not a camera or otherwise not initialized this function will return the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>camera node to get matrix from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">time</td><td>absolute time at which to calculate the matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>this matrix will be filled with the world to camera matrix for the requested time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start. ">AiCameraGetShutterStart</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8b488a6784866ddac341b74f0ff9ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiWorldToScreenMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a>&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes world to screen matrix. </p>
<p>Computes the matrix that transforms between world space and screen space. Screen space is defined such that +x is right, +y is up and looks down +z. After a homogenous transform and normalization by w, you will have x and y in [-1,+1] and z in [0,1] (which correspond to near and far clipping planes).</p>
<p>This function accounts for camera motion blur by calculating the matrix at the requested time. If you are not interested in motion information, you can use options.reference_time or <a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start. ">AiCameraGetShutterStart()</a> for time.</p>
<p>If the provided node is invalid, not a camera or otherwise not initialized this function will return the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>camera node to get matrix from </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">time</td><td>absolute time at which to calculate the matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>this matrix will be filled with the world to screen matrix for the requested time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__shader__util.html#gad42f91c8954bb803b6fd37c6590b2114" title="Fetch camera shutter start. ">AiCameraGetShutterStart</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga22ecdba64563716529b0469c02dec220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingMirroredBall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a world-space direction vector to texture coordinates (u,v) based on the mirrored-ball mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Pointer to location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to location in which to write v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad58be830148a466be59ee09803f67154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingAngularMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a world-space direction vector to texture coordinates (u,v) based on an angular mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Pointer to location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to location in which to write v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a54d8e31755fe9e1a2357df21cbf8bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingLatLong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a world-space direction vector to texture coordinates (u,v) based on the Latitude/Longitude mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Pointer to location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to location in which to write v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9fc7f5585a55621b5f147328b962da7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingCubicMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a world-space direction vector to texture coordnates (u,v) based on a cubic mapping. </p>
<p>The cubic environment map is composed of 6 faces and must have the following layout: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; A</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;BCD</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; E</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; F</div></div><!-- fragment --><p> This is also known as the Vertical Cross Cube format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Pointer to location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to location in which to write v</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Don't use this dubious mapping, it will be removed in a future release. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4fc493fc271d4513ee8580bf68ef763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingMirroredBallDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dDdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dDdy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative version of <a class="el" href="group__ai__shader__util.html#ga22ecdba64563716529b0469c02dec220" title="Maps a world-space direction vector to texture coordinates (u,v) based on the mirrored-ball mapping...">AiMappingMirroredBall()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdx</td><td>Directional derivative of the ray with respect to the x pixel coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdy</td><td>Directional derivative of the ray with respect to the y pixel coordinate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Pointer to location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to location in which to write v </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudx</td><td>Pointer to location in which to write dudx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudy</td><td>Pointer to location in which to write dudy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdx</td><td>Pointer to location in which to write dvdx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdy</td><td>Pointer to location in which to write dvdy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f02494812af63a19e6f39c15536c87c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingAngularMapDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dDdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dDdy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative version of <a class="el" href="group__ai__shader__util.html#gad58be830148a466be59ee09803f67154" title="Maps a world-space direction vector to texture coordinates (u,v) based on an angular mapping...">AiMappingAngularMap()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdx</td><td>Directional derivative of the ray with respect to the x pixel coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdy</td><td>Directional derivative of the ray with respect to the y pixel coordinate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Pointer to location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to location in which to write v </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudx</td><td>Pointer to location in which to write dudx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudy</td><td>Pointer to location in which to write dudy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdx</td><td>Pointer to location in which to write dvdx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdy</td><td>Pointer to location in which to write dvdy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaca6167bab11dbf8c2f89d7cc7157cb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingLatLongDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dDdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dDdy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative version of <a class="el" href="group__ai__shader__util.html#ga4a54d8e31755fe9e1a2357df21cbf8bd" title="Maps a world-space direction vector to texture coordinates (u,v) based on the Latitude/Longitude mapp...">AiMappingLatLong()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdx</td><td>Directional derivative of the ray with respect to the x pixel coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdy</td><td>Directional derivative of the ray with respect to the y pixel coordinate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Pointer to location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to location in which to write v </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudx</td><td>Pointer to location in which to write dudx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudy</td><td>Pointer to location in which to write dudy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdx</td><td>Pointer to location in which to write dvdx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdy</td><td>Pointer to location in which to write dvdy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae8b89253089de91e290266302dc96a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMappingCubicMapDerivs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dDdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dDdy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dudx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dudy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dvdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dvdy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative version of <a class="el" href="group__ai__shader__util.html#ga9fc7f5585a55621b5f147328b962da7b" title="Maps a world-space direction vector to texture coordnates (u,v) based on a cubic mapping. ">AiMappingCubicMap()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>World-space direction vector </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdx</td><td>Directional derivative of the ray with respect to the x pixel coordinate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dDdy</td><td>Directional derivative of the ray with respect to the y pixel coordinate </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>Pointer to location in which to write u </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Pointer to location in which to write v </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudx</td><td>Pointer to location in which to write dudx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dudy</td><td>Pointer to location in which to write dudy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdx</td><td>Pointer to location in which to write dvdx </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dvdy</td><td>Pointer to location in which to write dvdy</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Don't use this dubious mapping, it will be removed in a future release. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2009-2016 Solid Angle SL &middot all rights reserved &middot <a href="http://www.solidangle.com"><font size=-2 color=#C9C9C9>www.solidangle.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
