<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arnold 4.2.14.2 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Procedural API</div>  </div>
</div><!--header-->
<div class="contents">

<p>This API is used to create geometry procedurally at render time, rather than upfront.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtProcVtable.html">AtProcVtable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural function table.  <a href="structAtProcVtable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga92dba775121e567104a15fae1f1eac7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga92dba775121e567104a15fae1f1eac7a">proc_loader</a>&#160;&#160;&#160;<a class="el" href="group__ai__plugins.html#ga95e724cd6a8385c2cea8d7fddc3a5d28">AI_EXPORT_LIB</a> int ProcLoader(<a class="el" href="structAtProcVtable.html">AtProcVtable</a>* vtable)</td></tr>
<tr class="memdesc:ga92dba775121e567104a15fae1f1eac7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy shortcut for writing procedurals.  <a href="#ga92dba775121e567104a15fae1f1eac7a">More...</a><br /></td></tr>
<tr class="separator:ga92dba775121e567104a15fae1f1eac7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabe22e779f829554abd93e48ea4902143"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#gabe22e779f829554abd93e48ea4902143">AtProcInitPlugin</a>) (void **plugin_user_ptr)</td></tr>
<tr class="memdesc:gabe22e779f829554abd93e48ea4902143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural plugin init method.  <a href="#gabe22e779f829554abd93e48ea4902143">More...</a><br /></td></tr>
<tr class="separator:gabe22e779f829554abd93e48ea4902143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade448822e6674f3f63f3ea5d58923888"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#gade448822e6674f3f63f3ea5d58923888">AtProcCleanupPlugin</a>) (void *plugin_user_ptr)</td></tr>
<tr class="memdesc:gade448822e6674f3f63f3ea5d58923888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural plugin cleanup method.  <a href="#gade448822e6674f3f63f3ea5d58923888">More...</a><br /></td></tr>
<tr class="separator:gade448822e6674f3f63f3ea5d58923888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369dc9a319023b2f49fe0e41c75fe492"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga369dc9a319023b2f49fe0e41c75fe492">AtProcInitBounds</a>) (<a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtBBox.html">AtBBox</a> *bounds, void **user_ptr)</td></tr>
<tr class="memdesc:ga369dc9a319023b2f49fe0e41c75fe492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural init bounds method.  <a href="#ga369dc9a319023b2f49fe0e41c75fe492">More...</a><br /></td></tr>
<tr class="separator:ga369dc9a319023b2f49fe0e41c75fe492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0f51d3c111b02fef3cf1a9c9e6d02a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a>) (<a class="el" href="structAtNode.html">AtNode</a> *node, void **user_ptr)</td></tr>
<tr class="memdesc:gada0f51d3c111b02fef3cf1a9c9e6d02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural init method.  <a href="#gada0f51d3c111b02fef3cf1a9c9e6d02a">More...</a><br /></td></tr>
<tr class="separator:gada0f51d3c111b02fef3cf1a9c9e6d02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7de3a0c8d9d648a5e44496d4afadfc"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga2b7de3a0c8d9d648a5e44496d4afadfc">AtProcCleanup</a>) (void *user_ptr)</td></tr>
<tr class="memdesc:ga2b7de3a0c8d9d648a5e44496d4afadfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural cleanup method.  <a href="#ga2b7de3a0c8d9d648a5e44496d4afadfc">More...</a><br /></td></tr>
<tr class="separator:ga2b7de3a0c8d9d648a5e44496d4afadfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b46727711a0987c684d81dcd88bcca"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga65b46727711a0987c684d81dcd88bcca">AtProcNumNodes</a>) (void *user_ptr)</td></tr>
<tr class="memdesc:ga65b46727711a0987c684d81dcd88bcca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural node count method.  <a href="#ga65b46727711a0987c684d81dcd88bcca">More...</a><br /></td></tr>
<tr class="separator:ga65b46727711a0987c684d81dcd88bcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e9e4c1438b4abd859ea040c8b84f3d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structAtNode.html">AtNode</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#gae4e9e4c1438b4abd859ea040c8b84f3d">AtProcGetNode</a>) (void *user_ptr, int i)</td></tr>
<tr class="memdesc:gae4e9e4c1438b4abd859ea040c8b84f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural node fetching method.  <a href="#gae4e9e4c1438b4abd859ea040c8b84f3d">More...</a><br /></td></tr>
<tr class="separator:gae4e9e4c1438b4abd859ea040c8b84f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c4c82eb47296af6256f9264053de0c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structAtProcVtable.html">AtProcVtable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga21c4c82eb47296af6256f9264053de0c">AtProcVtable</a></td></tr>
<tr class="memdesc:ga21c4c82eb47296af6256f9264053de0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural function table.  <a href="#ga21c4c82eb47296af6256f9264053de0c">More...</a><br /></td></tr>
<tr class="separator:ga21c4c82eb47296af6256f9264053de0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0372ae9b272d72e26834a478a7b93dc8"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga0372ae9b272d72e26834a478a7b93dc8">AtProcLoader</a>) (<a class="el" href="structAtProcVtable.html">AtProcVtable</a> *vtable)</td></tr>
<tr class="memdesc:ga0372ae9b272d72e26834a478a7b93dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural entry-point symbol.  <a href="#ga0372ae9b272d72e26834a478a7b93dc8">More...</a><br /></td></tr>
<tr class="separator:ga0372ae9b272d72e26834a478a7b93dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga41184913409e2d3792f712bece48db67"><td class="memItemLeft" align="right" valign="top">AI_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__procedurals.html#ga41184913409e2d3792f712bece48db67">AiProceduralGetPluginData</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga41184913409e2d3792f712bece48db67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get shared data for an entire procedural plugin.  <a href="#ga41184913409e2d3792f712bece48db67">More...</a><br /></td></tr>
<tr class="separator:ga41184913409e2d3792f712bece48db67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This API is used to create geometry procedurally at render time, rather than upfront. </p>
<p>This is accomplished by providing the renderer some callback functions which are called as needed, on-demand, possibly by multiple threads, when the procedural's bounding box is hit by any ray. Procedural nodes should only declare geometry and perhaps shader nodes. In particular, light sources cannot be created on-demand during rendering.</p>
<p>Note that procedurals can recursively create other procedural nodes. This allows small scene files to define huge scenes, where every piece of geometry is loaded on-demand: geometry that is not visible by the camera (or by other types of rays, e.g. reflection) will never be loaded in memory.</p>
<p>There is a special mode, enabled by setting the procedural's load_at_init=true, that will force the loading of the procedural during the pre-render initialization process. In this mode, the procedural will be loaded serially (unless it was created from another procedural which is being created during rendering, in which case it will be executed in the current thread, possibly in parallel with others). This mode can be enabled for all procedural nodes simultaneously by setting the global option <code>procedural_force_expand</code>.</p>
<p>So, in most cases, when rendering with multiple threads, procedural nodes can be expanded in parallel. It is therefore necessary that the code in a procedural node is properly designed to be re-entrant. If the code is not re-entrant, the global option <code>enable_threaded_procedurals</code> can be used to prevent undefined behaviour. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga92dba775121e567104a15fae1f1eac7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define proc_loader&#160;&#160;&#160;<a class="el" href="group__ai__plugins.html#ga95e724cd6a8385c2cea8d7fddc3a5d28">AI_EXPORT_LIB</a> int ProcLoader(<a class="el" href="structAtProcVtable.html">AtProcVtable</a>* vtable)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handy shortcut for writing procedurals. </p>
<p>This is a shorter, alternate way to declare the <a class="el" href="group__ai__procedurals.html#ga0372ae9b272d72e26834a478a7b93dc8">AtProcLoader</a> symbol. Here is an example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;node_loader </div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;   vtable-&gt;InitPlugin    = MyInitPlugin;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   vtable-&gt;CleanupPlugin = MyCleanupPlugin;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   vtable-&gt;InitBounds    = MyInitBounds;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;   vtable-&gt;Init          = MyInit;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   vtable-&gt;Cleanup       = MyCleanup;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   vtable-&gt;NumNodes      = MyNumNodes;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;   vtable-&gt;GetNode       = MyGetNode;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;   strcpy(vtable-&gt;version, AI_VERSION);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;   return true;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gabe22e779f829554abd93e48ea4902143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtProcInitPlugin) (void **plugin_user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural plugin init method. </p>
<p>This method will be called once for the entire session in which the procedural is used, no matter how many procedurals of this type there are. If there is data to be shared between procedural nodes using this procedural plugin, it can be created here. This is an optional method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">plugin_user_ptr</td><td>This is a general-purpose, user-supplied data pointer that later can be accessed via <a class="el" href="group__ai__procedurals.html#ga41184913409e2d3792f712bece48db67">AiProceduralGetPluginData</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="gade448822e6674f3f63f3ea5d58923888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtProcCleanupPlugin) (void *plugin_user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural plugin cleanup method. </p>
<p>This method will be called once at the end of the entire session in which the procedural is used, no matter how many procedurals of this type there are. If there was data shared between procedural nodes using this plugin, it should be destroyed here. This is an optional method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plugin_user_ptr</td><td>This is a general-purpose, user-supplied data pointer that came from <a class="el" href="group__ai__procedurals.html#gabe22e779f829554abd93e48ea4902143">AtProcInitPlugin</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="ga369dc9a319023b2f49fe0e41c75fe492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* AtProcInitBounds) (<a class="el" href="structAtNode.html">AtNode</a> *node, <a class="el" href="structAtBBox.html">AtBBox</a> *bounds, void **user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural init bounds method. </p>
<p>This method will be called when a procedural node is initialized, to compute bounds at runtime. This is an optional method and if not provided the bounds specified in the node min and max parameters will be used. If this method is provided it can override the bounds.</p>
<p>The user-supplied data pointer will be passed along to the other procedural methods, and can store data that is re-used when the procedural is expanded, to avoid doing the same computations twice.</p>
<p>Since the procedural may never be expanded, this method should not create any nodes and should execute quickly, with the heavier computations performed in <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a>.</p>
<p>This method may be called concurrently with other uses of the same procedural plugin, unless "options.enable_threaded_procedurals" is off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>This is the procedural node itself </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bounds</td><td>Runtime computed bounds of the procedural </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_ptr</td><td>This is a general-purpose, user-supplied data pointer that Arnold will pass along to the other procedural methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="gada0f51d3c111b02fef3cf1a9c9e6d02a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcInit) (<a class="el" href="structAtNode.html">AtNode</a> *node, void **user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural init method. </p>
<p>This method will be called first and should perform any initialization required by your procedural. You probably want to create new nodes inside this method but you should return them through <a class="el" href="group__ai__procedurals.html#gae4e9e4c1438b4abd859ea040c8b84f3d">AtProcGetNode</a> and correctly return the number of created nodes from <a class="el" href="group__ai__procedurals.html#ga65b46727711a0987c684d81dcd88bcca">AtProcNumNodes</a>, otherwise the behavior is undefined. Alternatively, if you know ahead of time exactly how many nodes you are going to create, you can create them in <a class="el" href="group__ai__procedurals.html#gae4e9e4c1438b4abd859ea040c8b84f3d">AtProcGetNode</a> too.</p>
<p>This method may be called concurrently with other uses of the same procedural plugin, unless "options.enable_threaded_procedurals" is off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">node</td><td>This is the procedural node itself </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">user_ptr</td><td>This is a general-purpose, user-supplied data pointer that Arnold will pass along to the other procedural methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b7de3a0c8d9d648a5e44496d4afadfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcCleanup) (void *user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural cleanup method. </p>
<p>This method will be called last and should perform any cleanup required by your procedural. Make sure you release any memory you allocated that is no longer needed by Arnold.</p>
<p>This method may be called concurrently with other uses of the same procedural plugin, unless "options.enable_threaded_procedurals" is off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<a class="anchor" id="ga65b46727711a0987c684d81dcd88bcca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcNumNodes) (void *user_ptr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural node count method. </p>
<p>This method will be called after initialization and should report the exact number of nodes to be created.</p>
<p>This method may be called concurrently with other uses of the same procedural plugin, unless "options.enable_threaded_procedurals" is off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes in the procedural </dd></dl>

</div>
</div>
<a class="anchor" id="gae4e9e4c1438b4abd859ea040c8b84f3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structAtNode.html">AtNode</a>*(* AtProcGetNode) (void *user_ptr, int i)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural node fetching method. </p>
<p>This method will be called once for each node to be created (as determined by <a class="el" href="group__ai__procedurals.html#ga65b46727711a0987c684d81dcd88bcca">AtProcNumNodes</a>). Note that if you created any node in <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a>, they also should be returned here, otherwise the behaviour would be undefined.</p>
<p>This method may be called concurrently with other uses of the same procedural plugin, unless "options.enable_threaded_procedurals" is off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_ptr</td><td>User data pointer, as returned from <a class="el" href="group__ai__procedurals.html#gada0f51d3c111b02fef3cf1a9c9e6d02a">AtProcInit</a> </td></tr>
    <tr><td class="paramname">i</td><td>Node index, in the range 0 to <a class="el" href="group__ai__procedurals.html#ga65b46727711a0987c684d81dcd88bcca">AtProcNumNodes</a> - 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The i'th node in the procedural </dd></dl>

</div>
</div>
<a class="anchor" id="ga21c4c82eb47296af6256f9264053de0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structAtProcVtable.html">AtProcVtable</a>  <a class="el" href="structAtProcVtable.html">AtProcVtable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural function table. </p>
<p>This structure is used to report the function pointers that the renderer needs to call at runtime. The version field is used for runtime compatibility checking. These fields are pre-initialized to NULL when passed to ProcLoader. </p>

</div>
</div>
<a class="anchor" id="ga0372ae9b272d72e26834a478a7b93dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* AtProcLoader) (<a class="el" href="structAtProcVtable.html">AtProcVtable</a> *vtable)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procedural entry-point symbol. </p>
<p>Procedural DSO's must define a symbol named "ProcLoader" of this type. It should fill in the fields of a <a class="el" href="structAtProcVtable.html">AtProcVtable</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vtable</td><td>List of procedural methods (some of which are optional) to be supplied by the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true upon success </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga41184913409e2d3792f712bece48db67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void* AiProceduralGetPluginData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get shared data for an entire procedural plugin. </p>
<p>Given a particular node (which should be of type "procedural"), retrieve the shared data that was created by the procedural plugin.</p>
<p>Note that it is the caller's responsibility to lock any data access between threads.</p>
<p>Note also that the caller should not assume the data for a given procedural plugin is ready until rendering has already started.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Procedural node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Procedural plugin data, or NULL otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2009-2016 Solid Angle SL &middot all rights reserved &middot <a href="http://www.solidangle.com"><font size=-2 color=#C9C9C9>www.solidangle.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
