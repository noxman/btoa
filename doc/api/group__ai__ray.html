<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arnold 4.2.14.2 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ray Tracing API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtRay.html">AtRay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray data structure.  <a href="structAtRay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf14a6ebfb4366338a46fdc1eba6a6d1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf14a6ebfb4366338a46fdc1eba6a6d1f"></a>
typedef struct <a class="el" href="structAtRay.html">AtRay</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gaf14a6ebfb4366338a46fdc1eba6a6d1f">AtRay</a></td></tr>
<tr class="memdesc:gaf14a6ebfb4366338a46fdc1eba6a6d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray data structure. <br /></td></tr>
<tr class="separator:gaf14a6ebfb4366338a46fdc1eba6a6d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga40b0aa0fb98c334e689f20a1ccbce836"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#ga40b0aa0fb98c334e689f20a1ccbce836">AiMakeRay</a> (<a class="el" href="structAtRay.html">AtRay</a> *ray, <a class="el" href="group__ai__types.html#ga5e008e3afa9393ab65d66796de249df9">AtUInt32</a> type, const <a class="el" href="structAtPoint.html">AtPoint</a> *origin, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *dir, double maxdist, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga40b0aa0fb98c334e689f20a1ccbce836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a ray, before it can be traced.  <a href="#ga40b0aa0fb98c334e689f20a1ccbce836">More...</a><br /></td></tr>
<tr class="separator:ga40b0aa0fb98c334e689f20a1ccbce836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd44145a4c62dc77acf94a162b88238"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gaccd44145a4c62dc77acf94a162b88238">AiReflectRay</a> (<a class="el" href="structAtRay.html">AtRay</a> *ray, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *normal, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:gaccd44145a4c62dc77acf94a162b88238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and sets the reflected ray direction and proper ray direction differentials (ray-&gt;dDdx and ray-&gt;dDdy).  <a href="#gaccd44145a4c62dc77acf94a162b88238">More...</a><br /></td></tr>
<tr class="separator:gaccd44145a4c62dc77acf94a162b88238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595f5e039d80582f7a04ca001f44f78b"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#ga595f5e039d80582f7a04ca001f44f78b">AiRefractRay</a> (<a class="el" href="structAtRay.html">AtRay</a> *ray, const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *normal, float n1, float n2, const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg)</td></tr>
<tr class="memdesc:ga595f5e039d80582f7a04ca001f44f78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps make a refracted ray with high quality ray derivatives when called after <a class="el" href="group__ai__ray.html#ga40b0aa0fb98c334e689f20a1ccbce836" title="Initializes a ray, before it can be traced. ">AiMakeRay()</a>.  <a href="#ga595f5e039d80582f7a04ca001f44f78b">More...</a><br /></td></tr>
<tr class="separator:ga595f5e039d80582f7a04ca001f44f78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fe90481c4a0f57205d14230e800291"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gac6fe90481c4a0f57205d14230e800291">AiTrace</a> (const <a class="el" href="structAtRay.html">AtRay</a> *ray, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight, <a class="el" href="structAtScrSample.html">AtScrSample</a> *sample)</td></tr>
<tr class="memdesc:gac6fe90481c4a0f57205d14230e800291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traces a ray through the whole scene, and for non-shadow rays, the radiance and first-hit information will be returned.  <a href="#gac6fe90481c4a0f57205d14230e800291">More...</a><br /></td></tr>
<tr class="separator:gac6fe90481c4a0f57205d14230e800291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fbd81aedc02981d5fa2c1da27af0b6a"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#ga6fbd81aedc02981d5fa2c1da27af0b6a">AiTraceBackground</a> (const <a class="el" href="structAtRay.html">AtRay</a> *ray, <a class="el" href="structAtScrSample.html">AtScrSample</a> *sample)</td></tr>
<tr class="memdesc:ga6fbd81aedc02981d5fa2c1da27af0b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traces a ray against the background without touching the geometry.  <a href="#ga6fbd81aedc02981d5fa2c1da27af0b6a">More...</a><br /></td></tr>
<tr class="separator:ga6fbd81aedc02981d5fa2c1da27af0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4fd53fc9ae9941f8ea74aedadaa73e4"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gaa4fd53fc9ae9941f8ea74aedadaa73e4">AiTraceProbe</a> (const <a class="el" href="structAtRay.html">AtRay</a> *ray, <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sgout)</td></tr>
<tr class="memdesc:gaa4fd53fc9ae9941f8ea74aedadaa73e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traces a ray through the whole scene and returns the first intersection, if there is one.  <a href="#gaa4fd53fc9ae9941f8ea74aedadaa73e4">More...</a><br /></td></tr>
<tr class="separator:gaa4fd53fc9ae9941f8ea74aedadaa73e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Ray Types</h2></td></tr>
<tr class="memitem:gaa3c3736d9e2f5abb1226d37d47c217b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa3c3736d9e2f5abb1226d37d47c217b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gaa3c3736d9e2f5abb1226d37d47c217b3">AI_RAY_UNDEFINED</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:gaa3c3736d9e2f5abb1226d37d47c217b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">undefined type <br /></td></tr>
<tr class="separator:gaa3c3736d9e2f5abb1226d37d47c217b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad711a20b2b29190b7e0f631aac68a1b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad711a20b2b29190b7e0f631aac68a1b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gad711a20b2b29190b7e0f631aac68a1b1">AI_RAY_CAMERA</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:gad711a20b2b29190b7e0f631aac68a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ray originating at the camera <br /></td></tr>
<tr class="separator:gad711a20b2b29190b7e0f631aac68a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e7f458ea66760fae254376c2709f8e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6e7f458ea66760fae254376c2709f8e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#ga6e7f458ea66760fae254376c2709f8e3">AI_RAY_SHADOW</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ga6e7f458ea66760fae254376c2709f8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">shadow ray towards a light source <br /></td></tr>
<tr class="separator:ga6e7f458ea66760fae254376c2709f8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36121a76d8981c2a1f5b2abe5c2d2752"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga36121a76d8981c2a1f5b2abe5c2d2752"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#ga36121a76d8981c2a1f5b2abe5c2d2752">AI_RAY_REFLECTED</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:ga36121a76d8981c2a1f5b2abe5c2d2752"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror reflection ray <br /></td></tr>
<tr class="separator:ga36121a76d8981c2a1f5b2abe5c2d2752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1935ceb0d3176a3fc4bde699b1896383"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1935ceb0d3176a3fc4bde699b1896383"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#ga1935ceb0d3176a3fc4bde699b1896383">AI_RAY_REFRACTED</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:ga1935ceb0d3176a3fc4bde699b1896383"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror refraction ray <br /></td></tr>
<tr class="separator:ga1935ceb0d3176a3fc4bde699b1896383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe958b9203acb9bf0210eef9e1a11346"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe958b9203acb9bf0210eef9e1a11346"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gafe958b9203acb9bf0210eef9e1a11346">AI_RAY_SUBSURFACE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:gafe958b9203acb9bf0210eef9e1a11346"><td class="mdescLeft">&#160;</td><td class="mdescRight">subsurface scattering probe ray <br /></td></tr>
<tr class="separator:gafe958b9203acb9bf0210eef9e1a11346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d5a7bf099a76d81458baccc9fcb8dea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d5a7bf099a76d81458baccc9fcb8dea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#ga6d5a7bf099a76d81458baccc9fcb8dea">AI_RAY_DIFFUSE</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:ga6d5a7bf099a76d81458baccc9fcb8dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">indirect diffuse (also known as diffuse GI) ray <br /></td></tr>
<tr class="separator:ga6d5a7bf099a76d81458baccc9fcb8dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb85326e8a24457a00f17de037f542a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb85326e8a24457a00f17de037f542a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gabb85326e8a24457a00f17de037f542a5">AI_RAY_GLOSSY</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:gabb85326e8a24457a00f17de037f542a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">glossy/blurred reflection ray <br /></td></tr>
<tr class="separator:gabb85326e8a24457a00f17de037f542a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb30bfd3ebc92760c54010b07ee178f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb30bfd3ebc92760c54010b07ee178f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#gabb30bfd3ebc92760c54010b07ee178f8">AI_RAY_ALL</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:gabb30bfd3ebc92760c54010b07ee178f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask for all ray types <br /></td></tr>
<tr class="separator:gabb30bfd3ebc92760c54010b07ee178f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0d8e7d9c447be4adc3ebb78d3d3e6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6a0d8e7d9c447be4adc3ebb78d3d3e6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__ray.html#ga6a0d8e7d9c447be4adc3ebb78d3d3e6a">AI_RAY_GENERIC</a>&#160;&#160;&#160;<a class="el" href="group__ai__ray.html#gabb30bfd3ebc92760c54010b07ee178f8">AI_RAY_ALL</a></td></tr>
<tr class="memdesc:ga6a0d8e7d9c447be4adc3ebb78d3d3e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask for all ray types <br /></td></tr>
<tr class="separator:ga6a0d8e7d9c447be4adc3ebb78d3d3e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga40b0aa0fb98c334e689f20a1ccbce836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMakeRay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtRay.html">AtRay</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__types.html#ga5e008e3afa9393ab65d66796de249df9">AtUInt32</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtPoint.html">AtPoint</a> *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxdist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a ray, before it can be traced. </p>
<p>Fill in an <a class="el" href="structAtRay.html" title="Ray data structure. ">AtRay</a> with user-provided origin and direction, plus information stored in a shader globals context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ray</td><td>previously allocated <a class="el" href="structAtRay.html" title="Ray data structure. ">AtRay</a> structure that will be filled in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>the type of ray that we want to create, one of <code>AI_RAY_*</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">origin</td><td>the origin of the ray </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>the direction of the ray (or NULL if not yet available) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxdist</td><td>the maximum distance that the ray will travel </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the shader globals context where the ray is created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaccd44145a4c62dc77acf94a162b88238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiReflectRay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtRay.html">AtRay</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and sets the reflected ray direction and proper ray direction differentials (ray-&gt;dDdx and ray-&gt;dDdy). </p>
<p>Note that <a class="el" href="group__ai__ray.html#ga40b0aa0fb98c334e689f20a1ccbce836" title="Initializes a ray, before it can be traced. ">AiMakeRay()</a> already computes proper ray direction differentials, so usually it is not necessary to also call AiReflectRay and instead it is more efficient to just use <a class="el" href="group__ai__shader__util.html#ga665643deecf3afbb7162a66b82d5d2fe" title="Returns specular direction R from incident direction I and normal N. ">AiReflect()</a> followed by <a class="el" href="group__ai__ray.html#ga40b0aa0fb98c334e689f20a1ccbce836" title="Initializes a ray, before it can be traced. ">AiMakeRay()</a>. However, if the ray direction and derivatives need to be updated, such as might happen when computing glossy reflections where only the shading normal is jittered for each ray, then it is more efficient to use the lighter weight <a class="el" href="group__ai__ray.html#gaccd44145a4c62dc77acf94a162b88238" title="Computes and sets the reflected ray direction and proper ray direction differentials (ray-&gt;dDdx and r...">AiReflectRay()</a> instead of <a class="el" href="group__ai__shader__util.html#ga665643deecf3afbb7162a66b82d5d2fe" title="Returns specular direction R from incident direction I and normal N. ">AiReflect()</a>+AiMakeRay().</p>
<p>An example usage is the following: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtRay ray;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AiMakeRay(&amp;ray, AI_RAY_REFLECTED, &amp;sg-&gt;P, NULL, AI_BIG, sg);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;while (condition) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   AiReflectRay(&amp;ray, getNewJitteredNormal(), sg);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   AiTrace(&amp;ray, sample);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ray</td><td>the <a class="el" href="structAtRay.html" title="Ray data structure. ">AtRay</a> which will contain the reflection direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">normal</td><td>the shading normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the shader globals context for this shader evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga595f5e039d80582f7a04ca001f44f78b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiRefractRay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtRay.html">AtRay</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a> *&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>n2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps make a refracted ray with high quality ray derivatives when called after <a class="el" href="group__ai__ray.html#ga40b0aa0fb98c334e689f20a1ccbce836" title="Initializes a ray, before it can be traced. ">AiMakeRay()</a>. </p>
<p>Note, if called before <a class="el" href="group__ai__ray.html#ga40b0aa0fb98c334e689f20a1ccbce836" title="Initializes a ray, before it can be traced. ">AiMakeRay()</a> instead of after, then the correctly computed ray derivatives will be overwritten by the low quality ray derivatives created by <a class="el" href="group__ai__ray.html#ga40b0aa0fb98c334e689f20a1ccbce836" title="Initializes a ray, before it can be traced. ">AiMakeRay()</a>! <a class="el" href="group__ai__ray.html#ga40b0aa0fb98c334e689f20a1ccbce836" title="Initializes a ray, before it can be traced. ">AiMakeRay()</a> cannot produce high quality ray derivatives because it does not have access to the indices of refraction.</p>
<p>This will update the <a class="el" href="structAtRay.html" title="Ray data structure. ">AtRay</a> to contain the refracted (or total internal reflection) ray direction and also set the proper ray direction differentials (ray-&gt;dDdx and ray-&gt;dDdy) for refraction (or total internal reflection).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtRay ray;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AiMakeRay(&amp;ray, AI_RAY_REFRACTED, &amp;sg-&gt;P, NULL, AI_BIG, sg);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AiRefractRay(&amp;ray, &amp;sg-&gt;Nf, n1, n2, sg);</div></div><!-- fragment --><p>If many reflected rays will be cast from the same shading point, but say with a different normal each time, it is more efficient to reuse the ray:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtRay ray;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AiMakeRay(&amp;ray, AI_RAY_REFRACTED, &amp;sg-&gt;P, NULL, AI_BIG, sg);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;while (condition) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   AiRefractRay(&amp;ray, getNewJitteredNormal(), n1, n2, sg);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   AiTrace(&amp;ray, sample);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ray</td><td>the <a class="el" href="structAtRay.html" title="Ray data structure. ">AtRay</a> which will contain the refraction/TIR ray direction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">normal</td><td>the shading normal </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n1</td><td>index of refraction (IOR) of the medium the incident ray travels in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n2</td><td>index of refraction (IOR) of the medium the transmitted ray travels in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sg</td><td>the shader globals context for this shader evaluation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean which is true if refraction occurred or false if TIR occurred </dd></dl>

</div>
</div>
<a class="anchor" id="gac6fe90481c4a0f57205d14230e800291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AiTrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtRay.html">AtRay</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtScrSample.html">AtScrSample</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traces a ray through the whole scene, and for non-shadow rays, the radiance and first-hit information will be returned. </p>
<p>Shadow rays only return opacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ray</td><td>the ray to be traced </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">weight</td><td>RGB weight applied to the result color, and used for Russian roulette termination for more efficient rendering with high GI depth </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>a non-NULL pointer to an <a class="el" href="structAtScrSample.html" title="Used to hold the result of AiTrace() calls. ">AtScrSample</a> structure where the radiance and first-hit information of non-shadow rays are returned. Shadow rays will only have opacity filled in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the ray hit something </dd></dl>

</div>
</div>
<a class="anchor" id="ga6fbd81aedc02981d5fa2c1da27af0b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiTraceBackground </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtRay.html">AtRay</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtScrSample.html">AtScrSample</a> *&#160;</td>
          <td class="paramname"><em>sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traces a ray against the background without touching the geometry. </p>
<p>Allows shader writers to easily trace a ray against the background, without intersecting geometry first. This can be useful when implementing limited ray-length effects or environment mapped reflections. Note that this function includes the contribution from the atmosphere shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ray</td><td>the ray to be traced </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sample</td><td>a non-NULL pointer to an <a class="el" href="structAtScrSample.html" title="Used to hold the result of AiTrace() calls. ">AtScrSample</a> structure where the radiance and opacity are returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa4fd53fc9ae9941f8ea74aedadaa73e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiTraceProbe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtRay.html">AtRay</a> *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sgout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traces a ray through the whole scene and returns the first intersection, if there is one. </p>
<p>The ray will stop at the first geometric intersection. This function does not take transparency into account.</p>
<p>Note: If the ray type is specifically set to <code>AI_RAY_SHADOW</code>, this function will return the first intersection found as the ray traverses the scene hierarchy. This is faster if you just want to know if the ray hits <em>any</em> object, but it might not be the closest intersection along the ray path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ray</td><td>the ray to be traced </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sgout</td><td>if non-NULL, the first intersection point will be stored here </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the ray hit something </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2009-2016 Solid Angle SL &middot all rights reserved &middot <a href="http://www.solidangle.com"><font size=-2 color=#C9C9C9>www.solidangle.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
