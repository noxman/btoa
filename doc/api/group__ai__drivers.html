<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arnold 4.2.14.2 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Output Driver Nodes</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtDriverNodeMethods.html">AtDriverNodeMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver Node methods structure.  <a href="structAtDriverNodeMethods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga407ac5c17630ff9d583da3490a06d8b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga407ac5c17630ff9d583da3490a06d8b3">AI_DRIVER_NODE_EXPORT_METHODS</a>(tag)              </td></tr>
<tr class="memdesc:ga407ac5c17630ff9d583da3490a06d8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output Driver node methods exporter.  <a href="#ga407ac5c17630ff9d583da3490a06d8b3">More...</a><br /></td></tr>
<tr class="separator:ga407ac5c17630ff9d583da3490a06d8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae6697d7e30a29095265fae9bc27cfe61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6697d7e30a29095265fae9bc27cfe61"></a>
typedef struct <a class="el" href="structAtDriverNodeMethods.html">AtDriverNodeMethods</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gae6697d7e30a29095265fae9bc27cfe61">AtDriverNodeMethods</a></td></tr>
<tr class="memdesc:gae6697d7e30a29095265fae9bc27cfe61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver Node methods structure. <br /></td></tr>
<tr class="separator:gae6697d7e30a29095265fae9bc27cfe61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Quantization and Dithering</h2></td></tr>
<tr class="memitem:ga63a2d08fddddec1ad021521d5256324f"><td class="memItemLeft" align="right" valign="top">AI_API AI_CONST <a class="el" href="group__ai__types.html#ga2c04fab5be631c65ccf66ecbd5a01788">AtUInt8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga63a2d08fddddec1ad021521d5256324f">AiQuantize8bit</a> (int x, int y, int i, float value, bool dither)</td></tr>
<tr class="memdesc:ga63a2d08fddddec1ad021521d5256324f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantize a floating point number down to an 8-bit integer.  <a href="#ga63a2d08fddddec1ad021521d5256324f">More...</a><br /></td></tr>
<tr class="separator:ga63a2d08fddddec1ad021521d5256324f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd1c31290849501668bc552063fb1a5"><td class="memItemLeft" align="right" valign="top">AI_API AI_CONST <a class="el" href="group__ai__types.html#ga31e2774651e7b62b89c5628edfd63fa3">AtUInt16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gabcd1c31290849501668bc552063fb1a5">AiQuantize16bit</a> (int x, int y, int i, float value, bool dither)</td></tr>
<tr class="memdesc:gabcd1c31290849501668bc552063fb1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantize a floating point number down to a 16-bit integer.  <a href="#gabcd1c31290849501668bc552063fb1a5">More...</a><br /></td></tr>
<tr class="separator:gabcd1c31290849501668bc552063fb1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Method Declarations</h2></td></tr>
<tr class="memitem:gad18183b3cd0bc436a8087ca1d25850ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">driver_supports_pixel_type</a>&#160;&#160;&#160;static bool DriverSupportsPixelType(const <a class="el" href="structAtNode.html">AtNode</a>* node, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> pixel_type)</td></tr>
<tr class="memdesc:gad18183b3cd0bc436a8087ca1d25850ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_supports_pixel_type declaration.  <a href="#gad18183b3cd0bc436a8087ca1d25850ec">More...</a><br /></td></tr>
<tr class="separator:gad18183b3cd0bc436a8087ca1d25850ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b8895e83f19a5cbf53091bb52dd0e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gac0b8895e83f19a5cbf53091bb52dd0e8">driver_extension</a>&#160;&#160;&#160;static const char** DriverExtension()</td></tr>
<tr class="memdesc:gac0b8895e83f19a5cbf53091bb52dd0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_extension method declaration.  <a href="#gac0b8895e83f19a5cbf53091bb52dd0e8">More...</a><br /></td></tr>
<tr class="separator:gac0b8895e83f19a5cbf53091bb52dd0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4c1392f7280dcf596d833b27c63257"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga5c4c1392f7280dcf596d833b27c63257">driver_open</a>&#160;&#160;&#160;static void DriverOpen(<a class="el" href="structAtNode.html">AtNode</a>* node, struct AtOutputIterator* iterator, <a class="el" href="structAtBBox2.html">AtBBox2</a> display_window, <a class="el" href="structAtBBox2.html">AtBBox2</a> data_window, int bucket_size)</td></tr>
<tr class="memdesc:ga5c4c1392f7280dcf596d833b27c63257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_open method declaration.  <a href="#ga5c4c1392f7280dcf596d833b27c63257">More...</a><br /></td></tr>
<tr class="separator:ga5c4c1392f7280dcf596d833b27c63257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea47f8f7451d75112be4bfb1da5611b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gaea47f8f7451d75112be4bfb1da5611b5">driver_needs_bucket</a>&#160;&#160;&#160;static bool DriverNeedsBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, int tid)</td></tr>
<tr class="memdesc:gaea47f8f7451d75112be4bfb1da5611b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_needs_bucket method declaration.  <a href="#gaea47f8f7451d75112be4bfb1da5611b5">More...</a><br /></td></tr>
<tr class="separator:gaea47f8f7451d75112be4bfb1da5611b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0171f32654d3704a27b3177cfea5fc6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gac0171f32654d3704a27b3177cfea5fc6">driver_prepare_bucket</a>&#160;&#160;&#160;static void DriverPrepareBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, int tid)</td></tr>
<tr class="memdesc:gac0171f32654d3704a27b3177cfea5fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_prepare_bucket method declaration.  <a href="#gac0171f32654d3704a27b3177cfea5fc6">More...</a><br /></td></tr>
<tr class="separator:gac0171f32654d3704a27b3177cfea5fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad581a889a481b9c7ad1fddf92c2bc8b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gad581a889a481b9c7ad1fddf92c2bc8b7">driver_process_bucket</a>&#160;&#160;&#160;static void DriverProcessBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, struct AtOutputIterator* iterator, struct AtAOVSampleIterator* sample_iterator, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, int tid)</td></tr>
<tr class="memdesc:gad581a889a481b9c7ad1fddf92c2bc8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_process_bucket method declaration.  <a href="#gad581a889a481b9c7ad1fddf92c2bc8b7">More...</a><br /></td></tr>
<tr class="separator:gad581a889a481b9c7ad1fddf92c2bc8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7734e3bcc6deff211dec384a840fb09b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga7734e3bcc6deff211dec384a840fb09b">driver_write_bucket</a>&#160;&#160;&#160;static void DriverWriteBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, struct AtOutputIterator* iterator, struct AtAOVSampleIterator* sample_iterator, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y)</td></tr>
<tr class="memdesc:ga7734e3bcc6deff211dec384a840fb09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_write_bucket method declaration.  <a href="#ga7734e3bcc6deff211dec384a840fb09b">More...</a><br /></td></tr>
<tr class="separator:ga7734e3bcc6deff211dec384a840fb09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016be0537a02f4b1db64c69dd9667b71"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga016be0537a02f4b1db64c69dd9667b71">driver_close</a>&#160;&#160;&#160;static void DriverClose(<a class="el" href="structAtNode.html">AtNode</a>* node, struct AtOutputIterator* iterator)</td></tr>
<tr class="memdesc:ga016be0537a02f4b1db64c69dd9667b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver's driver_close method declaration.  <a href="#ga016be0537a02f4b1db64c69dd9667b71">More...</a><br /></td></tr>
<tr class="separator:ga016be0537a02f4b1db64c69dd9667b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
API for Driver Writers</h2></td></tr>
<tr class="memitem:ga0e1f8d8e6664b262fe60d8ec0b222845"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga0e1f8d8e6664b262fe60d8ec0b222845">AiDriverInitialize</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, bool supports_multiple_outputs, void *data)</td></tr>
<tr class="memdesc:ga0e1f8d8e6664b262fe60d8ec0b222845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes the driver structure.  <a href="#ga0e1f8d8e6664b262fe60d8ec0b222845">More...</a><br /></td></tr>
<tr class="separator:ga0e1f8d8e6664b262fe60d8ec0b222845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04c9312c8af1600a7da48f5ced71143"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gac04c9312c8af1600a7da48f5ced71143">AiRawDriverInitialize</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, const char **required_aovs, bool requires_depth, void *data)</td></tr>
<tr class="memdesc:gac04c9312c8af1600a7da48f5ced71143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes the driver structure.  <a href="#gac04c9312c8af1600a7da48f5ced71143">More...</a><br /></td></tr>
<tr class="separator:gac04c9312c8af1600a7da48f5ced71143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c37842ad842178c84f3d284b08f347"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gad6c37842ad842178c84f3d284b08f347">AiDriverDestroy</a> (<a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gad6c37842ad842178c84f3d284b08f347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an allocated driver structure.  <a href="#gad6c37842ad842178c84f3d284b08f347">More...</a><br /></td></tr>
<tr class="separator:gad6c37842ad842178c84f3d284b08f347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad951ac5ecaaa3f74a53ac66e1973a3b6"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gad951ac5ecaaa3f74a53ac66e1973a3b6">AiDriverGetLocalData</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gad951ac5ecaaa3f74a53ac66e1973a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the driver's local data pointer.  <a href="#gad951ac5ecaaa3f74a53ac66e1973a3b6">More...</a><br /></td></tr>
<tr class="separator:gad951ac5ecaaa3f74a53ac66e1973a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9cad53cebc3cee4b4e946c79b76496"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga9f9cad53cebc3cee4b4e946c79b76496">AiDriverGetMatrices</a> (<a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a> world_to_camera, <a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a> world_to_screen)</td></tr>
<tr class="memdesc:ga9f9cad53cebc3cee4b4e946c79b76496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Renderman compliant matrices from the active camera for use in file headers.  <a href="#ga9f9cad53cebc3cee4b4e946c79b76496">More...</a><br /></td></tr>
<tr class="separator:ga9f9cad53cebc3cee4b4e946c79b76496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30285cf3ebda1b2171551875a311e12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae30285cf3ebda1b2171551875a311e12"></a>
AI_API const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gae30285cf3ebda1b2171551875a311e12">AiDriverExtension</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *node_entry)</td></tr>
<tr class="memdesc:gae30285cf3ebda1b2171551875a311e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a driver's <a class="el" href="group__ai__drivers.html#gac0b8895e83f19a5cbf53091bb52dd0e8">driver_extension</a> method which returns a NULL-terminated array of filename extensions supported by this driver (note: uses the node_entry as this is a "static" method) <br /></td></tr>
<tr class="separator:gae30285cf3ebda1b2171551875a311e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8427e58854de0a75128c91a7cf36d8b6"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga8427e58854de0a75128c91a7cf36d8b6">AiOutputIteratorGetNext</a> (struct AtOutputIterator *iter, const char **output_name, int *pixel_type, const void **bucket_data)</td></tr>
<tr class="memdesc:ga8427e58854de0a75128c91a7cf36d8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the next output connected to a driver.  <a href="#ga8427e58854de0a75128c91a7cf36d8b6">More...</a><br /></td></tr>
<tr class="separator:ga8427e58854de0a75128c91a7cf36d8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4310f2e4fd550df2e2ba9b4d447b8833"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#ga4310f2e4fd550df2e2ba9b4d447b8833">AiOutputIteratorReset</a> (struct AtOutputIterator *iter)</td></tr>
<tr class="memdesc:ga4310f2e4fd550df2e2ba9b4d447b8833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset an output iterator.  <a href="#ga4310f2e4fd550df2e2ba9b4d447b8833">More...</a><br /></td></tr>
<tr class="separator:ga4310f2e4fd550df2e2ba9b4d447b8833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4c2ff572fb3ed2736888949766e337b"><td class="memItemLeft" align="right" valign="top">AI_API const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__drivers.html#gae4c2ff572fb3ed2736888949766e337b">AiFindDriverType</a> (const char *extension)</td></tr>
<tr class="memdesc:gae4c2ff572fb3ed2736888949766e337b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get correct driver node type from an extension.  <a href="#gae4c2ff572fb3ed2736888949766e337b">More...</a><br /></td></tr>
<tr class="separator:gae4c2ff572fb3ed2736888949766e337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Arnold supports pluggable output-file writers called "drivers". This output driver mechanism provides a pluggable architecture for writing output image files using Arnold's built-in AOV pipeline. It is also possible to write to arbitrary devices, such as a window display.</p>
<p>AOVs (Arbitrary Output Values) are organized into "layers", with each layer having a particular type (such as FLOAT or RGBA).</p>
<p>Drivers receive AOVs one bucket at a time which is perfectly suited to image-formats that are tiled. An iterator allows the driver to iterate through all the AOV layers contained in the bucket. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga407ac5c17630ff9d583da3490a06d8b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_DRIVER_NODE_EXPORT_METHODS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tag</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">AI_INSTANCE_COMMON_METHODS                         \</a></div><div class="line"><a class="code" href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">driver_supports_pixel_type</a>;                        <a class="code" href="group__ai__drivers.html#gac0b8895e83f19a5cbf53091bb52dd0e8">\</a></div><div class="line"><a class="code" href="group__ai__drivers.html#gac0b8895e83f19a5cbf53091bb52dd0e8">driver_extension</a>;                                  <a class="code" href="group__ai__drivers.html#ga5c4c1392f7280dcf596d833b27c63257">\</a></div><div class="line"><a class="code" href="group__ai__drivers.html#ga5c4c1392f7280dcf596d833b27c63257">driver_open</a>;                                       <a class="code" href="group__ai__drivers.html#gaea47f8f7451d75112be4bfb1da5611b5">\</a></div><div class="line"><a class="code" href="group__ai__drivers.html#gaea47f8f7451d75112be4bfb1da5611b5">driver_needs_bucket</a>;                               <a class="code" href="group__ai__drivers.html#gac0171f32654d3704a27b3177cfea5fc6">\</a></div><div class="line"><a class="code" href="group__ai__drivers.html#gac0171f32654d3704a27b3177cfea5fc6">driver_prepare_bucket</a>;                             <a class="code" href="group__ai__drivers.html#gad581a889a481b9c7ad1fddf92c2bc8b7">\</a></div><div class="line"><a class="code" href="group__ai__drivers.html#gad581a889a481b9c7ad1fddf92c2bc8b7">driver_process_bucket</a>;                             <a class="code" href="group__ai__drivers.html#ga7734e3bcc6deff211dec384a840fb09b">\</a></div><div class="line"><a class="code" href="group__ai__drivers.html#ga7734e3bcc6deff211dec384a840fb09b">driver_write_bucket</a>;                               <a class="code" href="group__ai__drivers.html#ga016be0537a02f4b1db64c69dd9667b71">\</a></div><div class="line"><a class="code" href="group__ai__drivers.html#ga016be0537a02f4b1db64c69dd9667b71">driver_close</a>;                                      \</div><div class="line">static <a class="code" href="structAtDriverNodeMethods.html">AtDriverNodeMethods</a> ai_driver_mtds = {      \</div><div class="line">   DriverSupportsPixelType,                        \</div><div class="line">   DriverExtension,                                \</div><div class="line">   DriverOpen,                                     \</div><div class="line">   DriverNeedsBucket,                              \</div><div class="line">   DriverPrepareBucket,                            \</div><div class="line">   DriverProcessBucket,                            \</div><div class="line">   DriverWriteBucket,                              \</div><div class="line">   DriverClose,                                    \</div><div class="line">};                                                 \</div><div class="line">static <a class="code" href="structAtNodeMethods.html">AtNodeMethods</a> ai_node_mtds = {              \</div><div class="line">   &amp;ai_common_mtds,                                \</div><div class="line">   &amp;ai_driver_mtds                                 \</div><div class="line">};                                                 \</div><div class="line">AtNodeMethods *tag = &amp;ai_node_mtds;</div><div class="ttc" id="group__ai__drivers_html_gad581a889a481b9c7ad1fddf92c2bc8b7"><div class="ttname"><a href="group__ai__drivers.html#gad581a889a481b9c7ad1fddf92c2bc8b7">driver_process_bucket</a></div><div class="ttdeci">#define driver_process_bucket</div><div class="ttdoc">Driver&amp;#39;s driver_process_bucket method declaration. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:174</div></div>
<div class="ttc" id="group__ai__drivers_html_gaea47f8f7451d75112be4bfb1da5611b5"><div class="ttname"><a href="group__ai__drivers.html#gaea47f8f7451d75112be4bfb1da5611b5">driver_needs_bucket</a></div><div class="ttdeci">#define driver_needs_bucket</div><div class="ttdoc">Driver&amp;#39;s driver_needs_bucket method declaration. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:134</div></div>
<div class="ttc" id="structAtNodeMethods_html"><div class="ttname"><a href="structAtNodeMethods.html">AtNodeMethods</a></div><div class="ttdoc">Node methods. </div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:56</div></div>
<div class="ttc" id="group__ai__drivers_html_gac0171f32654d3704a27b3177cfea5fc6"><div class="ttname"><a href="group__ai__drivers.html#gac0171f32654d3704a27b3177cfea5fc6">driver_prepare_bucket</a></div><div class="ttdeci">#define driver_prepare_bucket</div><div class="ttdoc">Driver&amp;#39;s driver_prepare_bucket method declaration. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:153</div></div>
<div class="ttc" id="group__ai__drivers_html_ga5c4c1392f7280dcf596d833b27c63257"><div class="ttname"><a href="group__ai__drivers.html#ga5c4c1392f7280dcf596d833b27c63257">driver_open</a></div><div class="ttdeci">#define driver_open</div><div class="ttdoc">Driver&amp;#39;s driver_open method declaration. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:116</div></div>
<div class="ttc" id="structAtDriverNodeMethods_html"><div class="ttname"><a href="structAtDriverNodeMethods.html">AtDriverNodeMethods</a></div><div class="ttdoc">Driver Node methods structure. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:42</div></div>
<div class="ttc" id="group__ai__drivers_html_gad18183b3cd0bc436a8087ca1d25850ec"><div class="ttname"><a href="group__ai__drivers.html#gad18183b3cd0bc436a8087ca1d25850ec">driver_supports_pixel_type</a></div><div class="ttdeci">#define driver_supports_pixel_type</div><div class="ttdoc">Driver&amp;#39;s driver_supports_pixel_type declaration. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:92</div></div>
<div class="ttc" id="group__ai__drivers_html_ga7734e3bcc6deff211dec384a840fb09b"><div class="ttname"><a href="group__ai__drivers.html#ga7734e3bcc6deff211dec384a840fb09b">driver_write_bucket</a></div><div class="ttdeci">#define driver_write_bucket</div><div class="ttdoc">Driver&amp;#39;s driver_write_bucket method declaration. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:193</div></div>
<div class="ttc" id="group__ai__drivers_html_gac0b8895e83f19a5cbf53091bb52dd0e8"><div class="ttname"><a href="group__ai__drivers.html#gac0b8895e83f19a5cbf53091bb52dd0e8">driver_extension</a></div><div class="ttdeci">#define driver_extension</div><div class="ttdoc">Driver&amp;#39;s driver_extension method declaration. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:101</div></div>
<div class="ttc" id="group__ai__drivers_html_ga016be0537a02f4b1db64c69dd9667b71"><div class="ttname"><a href="group__ai__drivers.html#ga016be0537a02f4b1db64c69dd9667b71">driver_close</a></div><div class="ttdeci">#define driver_close</div><div class="ttdoc">Driver&amp;#39;s driver_close method declaration. </div><div class="ttdef"><b>Definition:</b> ai_drivers.h:204</div></div>
</div><!-- fragment -->
<p>Output Driver node methods exporter. </p>

</div>
</div>
<a class="anchor" id="gad18183b3cd0bc436a8087ca1d25850ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_supports_pixel_type&#160;&#160;&#160;static bool DriverSupportsPixelType(const <a class="el" href="structAtNode.html">AtNode</a>* node, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> pixel_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_supports_pixel_type declaration. </p>
<p>Can the driver handle buckets of pixels of the specified type? This function is not called for raw mode drivers.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the driver can write pixels of the given type </dd></dl>

</div>
</div>
<a class="anchor" id="gac0b8895e83f19a5cbf53091bb52dd0e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_extension&#160;&#160;&#160;static const char** DriverExtension()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_extension method declaration. </p>
<dl class="section return"><dt>Returns</dt><dd>a NULL-terminated array of filename extensions which this driver is capable of writing. For example, a 'jpeg' driver might return the following array: { "jpeg", "jpg", NULL } </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c4c1392f7280dcf596d833b27c63257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_open&#160;&#160;&#160;static void DriverOpen(<a class="el" href="structAtNode.html">AtNode</a>* node, struct AtOutputIterator* iterator, <a class="el" href="structAtBBox2.html">AtBBox2</a> display_window, <a class="el" href="structAtBBox2.html">AtBBox2</a> data_window, int bucket_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_open method declaration. </p>
<p>This function is called before rendering starts and can make any preparations the driver needs, like opening a file or allocating memory. The list of connected outputs is passed in using an output iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">iterator</td><td>output iterator for outputs connected to this driver </td></tr>
    <tr><td class="paramname">display_window</td><td>this is a 2D bounding box for the actual resolution </td></tr>
    <tr><td class="paramname">data_window</td><td>this is the actual region of pixels that will be rendered </td></tr>
    <tr><td class="paramname">bucket_size</td><td>maximum width in pixels of a bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea47f8f7451d75112be4bfb1da5611b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_needs_bucket&#160;&#160;&#160;static bool DriverNeedsBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, int tid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_needs_bucket method declaration. </p>
<p>This function is called to determine if a bucket will be rendered. It can be used to continue work on partial images without re-rendering already present buckets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">bucket_xo</td><td>x coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_yo</td><td>y coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_size_x</td><td>width of the bucket in pixels </td></tr>
    <tr><td class="paramname">bucket_size_y</td><td>height of the bucket in pixels </td></tr>
    <tr><td class="paramname">tid</td><td>thread ID that will render this bucket</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bucket needs to be rendered, false if the bucket can be skipped </dd></dl>

</div>
</div>
<a class="anchor" id="gac0171f32654d3704a27b3177cfea5fc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_prepare_bucket&#160;&#160;&#160;static void DriverPrepareBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, int tid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_prepare_bucket method declaration. </p>
<p>This function is called before a bucket is rendered. It can be used to display bucket corners for interactive rendering drivers to show which buckets are being processed, for example. The renderer locks around this function so the contained code is not required to be thread safe. The bucket size may be smaller than what was given to <code>driver_open</code> because buckets are clamped to the edge of the render region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">bucket_xo</td><td>x coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_yo</td><td>y coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_size_x</td><td>width of the bucket in pixels </td></tr>
    <tr><td class="paramname">bucket_size_y</td><td>height of the bucket in pixels </td></tr>
    <tr><td class="paramname">tid</td><td>thread ID that will render this bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad581a889a481b9c7ad1fddf92c2bc8b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_process_bucket&#160;&#160;&#160;static void DriverProcessBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, struct AtOutputIterator* iterator, struct AtAOVSampleIterator* sample_iterator, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y, int tid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_process_bucket method declaration. </p>
<p>This function is called after a bucket has been rendered, but before it is written out. It provides the rendered pixels of each output to the driver, or the raw AOV samples if this is a raw driver. The renderer does not lock around this function, to allow for lengthy bucket preprocessing to happen in parallel. The contained code should not require any thread synchornization. The bucket size may be smaller than what was given to <code>driver_open</code> because buckets are clamped to the edge of the render region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">iterator</td><td>output iterator (loops over connected outputs for regular drivers) </td></tr>
    <tr><td class="paramname">sample_iterator</td><td>raw AOV sample iterator (loops over connected AOVs for raw drivers) </td></tr>
    <tr><td class="paramname">bucket_xo</td><td>x coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_yo</td><td>y coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_size_x</td><td>width of the bucket in pixels </td></tr>
    <tr><td class="paramname">bucket_size_y</td><td>height of the bucket in pixels </td></tr>
    <tr><td class="paramname">tid</td><td>thread ID that rendered this bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7734e3bcc6deff211dec384a840fb09b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_write_bucket&#160;&#160;&#160;static void DriverWriteBucket(<a class="el" href="structAtNode.html">AtNode</a>* node, struct AtOutputIterator* iterator, struct AtAOVSampleIterator* sample_iterator, int bucket_xo, int bucket_yo, int bucket_size_x, int bucket_size_y)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_write_bucket method declaration. </p>
<p>This function is called after a bucket has been rendered. It provides the rendered pixels of each output to the driver, or the raw AOV samples if this is a raw driver. The renderer locks around this function so the contained code is not required to be thread safe. The bucket size may be smaller than what was given to <code>driver_open</code> because buckets are clamped to the edge of the render region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">iterator</td><td>output iterator (loops over connected outputs for regular drivers) </td></tr>
    <tr><td class="paramname">sample_iterator</td><td>raw AOV sample iterator (loops over connected AOVs for raw drivers) </td></tr>
    <tr><td class="paramname">bucket_xo</td><td>x coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_yo</td><td>y coordinate of the bucket (upper-left) </td></tr>
    <tr><td class="paramname">bucket_size_x</td><td>width of the bucket in pixels </td></tr>
    <tr><td class="paramname">bucket_size_y</td><td>height of the bucket in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga016be0537a02f4b1db64c69dd9667b71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define driver_close&#160;&#160;&#160;static void DriverClose(<a class="el" href="structAtNode.html">AtNode</a>* node, struct AtOutputIterator* iterator)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver's driver_close method declaration. </p>
<p>This function is called after the image has finished rendering. It is responsible for any final tasks such as flushing or closing open files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node itself </td></tr>
    <tr><td class="paramname">iterator</td><td>output iterator (loops over connected outputs for regular drivers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga63a2d08fddddec1ad021521d5256324f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_CONST <a class="el" href="group__ai__types.html#ga2c04fab5be631c65ccf66ecbd5a01788">AtUInt8</a> AiQuantize8bit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dither</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantize a floating point number down to an 8-bit integer. </p>
<p>This function is typically used in an output driver to prepare pixel values before sending them to the output device. For example, we may want to send the continuous floating point image to a standard display with a limited color resolution of 8 bits per component.</p>
<p>Pixel quantization is a lossy process that can introduce distracting banding artifacts in the rendered image. This function optionally uses random dithering, which breaks the banding up into almost imperceptible noise. The input parameters <code>x</code>,<code>y</code> are used to lock the dither noise to the location of each pixel to prevent it from flickering in animation.</p>
<p>Usage example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtUInt8 r = AiQuantize8bit(x, y, 0, color.r, 1.0f);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AtUInt8 g = AiQuantize8bit(x, y, 1, color.g, 1.0f);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AtUInt8 b = AiQuantize8bit(x, y, 2, color.b, 1.0f);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>horizontal coordinate of the pixel to be quantized </td></tr>
    <tr><td class="paramname">y</td><td>vertical coordinate of the pixel to be quantized </td></tr>
    <tr><td class="paramname">i</td><td>instance number in 0..n-1, when part of a sequence of n calls </td></tr>
    <tr><td class="paramname">value</td><td>input floating point value to be quantized, in the [0,1] range </td></tr>
    <tr><td class="paramname">dither</td><td>use random dithering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>quantized value, in 0..255 </dd></dl>

</div>
</div>
<a class="anchor" id="gabcd1c31290849501668bc552063fb1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_CONST <a class="el" href="group__ai__types.html#ga31e2774651e7b62b89c5628edfd63fa3">AtUInt16</a> AiQuantize16bit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dither</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantize a floating point number down to a 16-bit integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>horizontal coordinate of the pixel to be quantized </td></tr>
    <tr><td class="paramname">y</td><td>vertical coordinate of the pixel to be quantized </td></tr>
    <tr><td class="paramname">i</td><td>instance number in 0..n-1, when part of a sequence of n calls </td></tr>
    <tr><td class="paramname">value</td><td>floating point value, in the [0,1] range </td></tr>
    <tr><td class="paramname">dither</td><td>use random dithering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>quantized value, in 0..65535</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__drivers.html#ga63a2d08fddddec1ad021521d5256324f" title="Quantize a floating point number down to an 8-bit integer. ">AiQuantize8bit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e1f8d8e6664b262fe60d8ec0b222845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiDriverInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supports_multiple_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes the driver structure. </p>
<p>This function creates an internal DriverNode structure and sets its data parameter to point to the incoming <code>data</code> pointer. This is the same data pointer that will be returned by the <a class="el" href="group__ai__drivers.html#gad951ac5ecaaa3f74a53ac66e1973a3b6" title="Get the driver&#39;s local data pointer. ">AiDriverGetLocalData()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node </td></tr>
    <tr><td class="paramname">supports_multiple_outputs</td><td>does this driver support more than one output routed to it? </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the driver's local data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac04c9312c8af1600a7da48f5ced71143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiRawDriverInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>required_aovs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requires_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and initializes the driver structure. </p>
<p>This function works just like <a class="el" href="group__ai__drivers.html#ga0e1f8d8e6664b262fe60d8ec0b222845" title="Allocates and initializes the driver structure. ">AiDriverInitialize()</a> but should only be used for raw drivers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node </td></tr>
    <tr><td class="paramname">required_aovs</td><td>NULL-terminated array of AOV descriptors (<code>"TYPE name"</code>) to route to this driver </td></tr>
    <tr><td class="paramname">requires_depth</td><td>should input AOVs be tracked with depth </td></tr>
    <tr><td class="paramname">data</td><td>pointer to the driver's local data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__drivers.html#ga0e1f8d8e6664b262fe60d8ec0b222845" title="Allocates and initializes the driver structure. ">AiDriverInitialize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad6c37842ad842178c84f3d284b08f347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiDriverDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an allocated driver structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad951ac5ecaaa3f74a53ac66e1973a3b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE void* AiDriverGetLocalData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the driver's local data pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>pointer to the driver node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local data pointer, as passed to <a class="el" href="group__ai__drivers.html#ga0e1f8d8e6664b262fe60d8ec0b222845" title="Allocates and initializes the driver structure. ">AiDriverInitialize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f9cad53cebc3cee4b4e946c79b76496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiDriverGetMatrices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a>&#160;</td>
          <td class="paramname"><em>world_to_camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__matrix.html#ga239cea4f70543ed6dae0d0549d28c01c">AtMatrix</a>&#160;</td>
          <td class="paramname"><em>world_to_screen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Renderman compliant matrices from the active camera for use in file headers. </p>
<p>This fetches the camera and screen matrices from the currently active camera so they can be placed in an output file's header. Note that unlike the camera API functions, the world to camera transform looks down +Z for compatibility with most file formats (TIFF,OpenEXR,dshd,...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">world_to_camera</td><td>world to camera transformation matrix (looking down +Z) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">world_to_screen</td><td>world to screen transformation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8427e58854de0a75128c91a7cf36d8b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiOutputIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtOutputIterator *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>output_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pixel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>bucket_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about the next output connected to a driver. </p>
<p>This method is meant to be called in a loop, though drivers that are designed to only accept a single output may call it just once. Each parameter is optional, and will only be written to when not NULL. The <code>bucket_data</code> parameter can only be obtained when writing a bucket. If this method returns false, the return values should not be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">iter</td><td>pointer to the iterator </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_name</td><td>the name of the AOV corresponding to this output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pixel_type</td><td>the type of the pixel data (<code>AI_TYPE_INT</code>, <code>AI_TYPE_RGB</code>, etc) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bucket_data</td><td>pointer to the start of the bucket data, pixel values will be stored in row major order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid output was present, false if the end of the output list was reached </dd></dl>

</div>
</div>
<a class="anchor" id="ga4310f2e4fd550df2e2ba9b4d447b8833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiOutputIteratorReset </td>
          <td>(</td>
          <td class="paramtype">AtOutputIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset an output iterator. </p>
<p>This method resets an output iterator so that the user may iterate over the outputs again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>pointer to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae4c2ff572fb3ed2736888949766e337b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a>* AiFindDriverType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get correct driver node type from an extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extension</td><td>a string containing the file extension, e.g. <code>"tiff"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold. ">AtNodeEntry</a> corresponding to <code>extension</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2009-2016 Solid Angle SL &middot all rights reserved &middot <a href="http://www.solidangle.com"><font size=-2 color=#C9C9C9>www.solidangle.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
