<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arnold 4.2.14.2 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AiUniverse API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Methods</h2></td></tr>
<tr class="memitem:ga3f1e23717da6afbcc58352b04ce1279c"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga3f1e23717da6afbcc58352b04ce1279c">AiUniverseIsActive</a> ()</td></tr>
<tr class="memdesc:ga3f1e23717da6afbcc58352b04ce1279c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the universe is active or not.  <a href="#ga3f1e23717da6afbcc58352b04ce1279c">More...</a><br /></td></tr>
<tr class="separator:ga3f1e23717da6afbcc58352b04ce1279c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf75f7ad717a03a79901f0ee59de45b"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gaaaf75f7ad717a03a79901f0ee59de45b">AiUniverseCacheFlush</a> (int cache_flags)</td></tr>
<tr class="memdesc:gaaaf75f7ad717a03a79901f0ee59de45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush one or several caches in the current universe.  <a href="#gaaaf75f7ad717a03a79901f0ee59de45b">More...</a><br /></td></tr>
<tr class="separator:gaaaf75f7ad717a03a79901f0ee59de45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa67e9b9b6fa73f729f35c8060fcf88d6"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gaa67e9b9b6fa73f729f35c8060fcf88d6">AiUniverseGetOptions</a> ()</td></tr>
<tr class="memdesc:gaa67e9b9b6fa73f729f35c8060fcf88d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the global options node.  <a href="#gaa67e9b9b6fa73f729f35c8060fcf88d6">More...</a><br /></td></tr>
<tr class="separator:gaa67e9b9b6fa73f729f35c8060fcf88d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78d93dd7b69b84f47896e042d7543a3"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gab78d93dd7b69b84f47896e042d7543a3">AiUniverseGetCamera</a> ()</td></tr>
<tr class="memdesc:gab78d93dd7b69b84f47896e042d7543a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the currently active camera node.  <a href="#gab78d93dd7b69b84f47896e042d7543a3">More...</a><br /></td></tr>
<tr class="separator:gab78d93dd7b69b84f47896e042d7543a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec9ad8303f46a7d2f758fcd7decf05e"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga1ec9ad8303f46a7d2f758fcd7decf05e">AiUniverseGetSceneBounds</a> ()</td></tr>
<tr class="memdesc:ga1ec9ad8303f46a7d2f758fcd7decf05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounding box of the scene.  <a href="#ga1ec9ad8303f46a7d2f758fcd7decf05e">More...</a><br /></td></tr>
<tr class="separator:ga1ec9ad8303f46a7d2f758fcd7decf05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0113dc8f5647d943d236bd3e74c7d3ab"><td class="memItemLeft" align="right" valign="top">AI_API AtNodeIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga0113dc8f5647d943d236bd3e74c7d3ab">AiUniverseGetNodeIterator</a> (unsigned int node_mask)</td></tr>
<tr class="memdesc:ga0113dc8f5647d943d236bd3e74c7d3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node iterator and resets it to the first node in the scene.  <a href="#ga0113dc8f5647d943d236bd3e74c7d3ab">More...</a><br /></td></tr>
<tr class="separator:ga0113dc8f5647d943d236bd3e74c7d3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5d47235f2b455ab0f62780c292e546"><td class="memItemLeft" align="right" valign="top">AI_API AtNodeEntryIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gaae5d47235f2b455ab0f62780c292e546">AiUniverseGetNodeEntryIterator</a> (unsigned int node_mask)</td></tr>
<tr class="memdesc:gaae5d47235f2b455ab0f62780c292e546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node entry iterator and resets it to the first installed node entry.  <a href="#gaae5d47235f2b455ab0f62780c292e546">More...</a><br /></td></tr>
<tr class="separator:gaae5d47235f2b455ab0f62780c292e546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3adf42cc4d820f5952fccc8778e4d5f0"><td class="memItemLeft" align="right" valign="top">AI_API AtAOVIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga3adf42cc4d820f5952fccc8778e4d5f0">AiUniverseGetAOVIterator</a> ()</td></tr>
<tr class="memdesc:ga3adf42cc4d820f5952fccc8778e4d5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new AOV iterator and resets it to the first entry.  <a href="#ga3adf42cc4d820f5952fccc8778e4d5f0">More...</a><br /></td></tr>
<tr class="separator:ga3adf42cc4d820f5952fccc8778e4d5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Iterator API</h2></td></tr>
<tr class="memitem:gac14e2b776f7e32dcb7346f64061f28ff"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff">AiNodeIteratorDestroy</a> (AtNodeIterator *iter)</td></tr>
<tr class="memdesc:gac14e2b776f7e32dcb7346f64061f28ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a node iterator when it is no longer needed.  <a href="#gac14e2b776f7e32dcb7346f64061f28ff">More...</a><br /></td></tr>
<tr class="separator:gac14e2b776f7e32dcb7346f64061f28ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9234a9aa9af990bcbb51ddd1313845d2"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga9234a9aa9af990bcbb51ddd1313845d2">AiNodeIteratorGetNext</a> (AtNodeIterator *iter)</td></tr>
<tr class="memdesc:ga9234a9aa9af990bcbb51ddd1313845d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current node and points node iterator to the next node.  <a href="#ga9234a9aa9af990bcbb51ddd1313845d2">More...</a><br /></td></tr>
<tr class="separator:ga9234a9aa9af990bcbb51ddd1313845d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6b120df6cb2b6b57dc700d04d5f118"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gaed6b120df6cb2b6b57dc700d04d5f118">AiNodeIteratorFinished</a> (const AtNodeIterator *iter)</td></tr>
<tr class="memdesc:gaed6b120df6cb2b6b57dc700d04d5f118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more nodes to iterate over.  <a href="#gaed6b120df6cb2b6b57dc700d04d5f118">More...</a><br /></td></tr>
<tr class="separator:gaed6b120df6cb2b6b57dc700d04d5f118"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Entry Iterator API</h2></td></tr>
<tr class="memitem:gacdbbbed549f79288819316f227def22f"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gacdbbbed549f79288819316f227def22f">AiNodeEntryIteratorDestroy</a> (AtNodeEntryIterator *iter)</td></tr>
<tr class="memdesc:gacdbbbed549f79288819316f227def22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a node entry iterator when it is no longer needed.  <a href="#gacdbbbed549f79288819316f227def22f">More...</a><br /></td></tr>
<tr class="separator:gacdbbbed549f79288819316f227def22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b0f41c673eb3a288f149dcea7b30bf"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gab8b0f41c673eb3a288f149dcea7b30bf">AiNodeEntryIteratorGetNext</a> (AtNodeEntryIterator *iter)</td></tr>
<tr class="memdesc:gab8b0f41c673eb3a288f149dcea7b30bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current node entry and points node entry iterator to the next node entry.  <a href="#gab8b0f41c673eb3a288f149dcea7b30bf">More...</a><br /></td></tr>
<tr class="separator:gab8b0f41c673eb3a288f149dcea7b30bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7978243ad260abcb7b6a7f2468aca7"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga2b7978243ad260abcb7b6a7f2468aca7">AiNodeEntryIteratorFinished</a> (const AtNodeEntryIterator *iter)</td></tr>
<tr class="memdesc:ga2b7978243ad260abcb7b6a7f2468aca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more node entries to iterate over.  <a href="#ga2b7978243ad260abcb7b6a7f2468aca7">More...</a><br /></td></tr>
<tr class="separator:ga2b7978243ad260abcb7b6a7f2468aca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
AOV Iterator API</h2></td></tr>
<tr class="memitem:gae3f61927424448febb6f7bd5b878b68d"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gae3f61927424448febb6f7bd5b878b68d">AiAOVIteratorDestroy</a> (AtAOVIterator *iter)</td></tr>
<tr class="memdesc:gae3f61927424448febb6f7bd5b878b68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a AOV iterator when it is no longer needed.  <a href="#gae3f61927424448febb6f7bd5b878b68d">More...</a><br /></td></tr>
<tr class="separator:gae3f61927424448febb6f7bd5b878b68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f21d84d92bd3f5fc42c96afc94542e1"><td class="memItemLeft" align="right" valign="top">AI_API const <a class="el" href="structAtAOVEntry.html">AtAOVEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#ga4f21d84d92bd3f5fc42c96afc94542e1">AiAOVIteratorGetNext</a> (AtAOVIterator *iter)</td></tr>
<tr class="memdesc:ga4f21d84d92bd3f5fc42c96afc94542e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current AOV entry and points AOV iterator to the next AOV.  <a href="#ga4f21d84d92bd3f5fc42c96afc94542e1">More...</a><br /></td></tr>
<tr class="separator:ga4f21d84d92bd3f5fc42c96afc94542e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb557694ef170cb568d03cdc543ed8f"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gabdb557694ef170cb568d03cdc543ed8f">AiAOVIteratorFinished</a> (const AtAOVIterator *iter)</td></tr>
<tr class="memdesc:gabdb557694ef170cb568d03cdc543ed8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more AOV entries to iterate over.  <a href="#gabdb557694ef170cb568d03cdc543ed8f">More...</a><br /></td></tr>
<tr class="separator:gabdb557694ef170cb568d03cdc543ed8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cache Types</h2></td></tr>
<tr class="memitem:gac5d80ecf4926d8537b9096991091f30c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5d80ecf4926d8537b9096991091f30c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gac5d80ecf4926d8537b9096991091f30c">AI_CACHE_TEXTURE</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:gac5d80ecf4926d8537b9096991091f30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all texturemaps. <br /></td></tr>
<tr class="separator:gac5d80ecf4926d8537b9096991091f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d21c12060a0af8631e34ba9edcd883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2d21c12060a0af8631e34ba9edcd883"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gad2d21c12060a0af8631e34ba9edcd883">AI_CACHE_HAIR_DIFFUSE</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:gad2d21c12060a0af8631e34ba9edcd883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes hair diffuse cache. <br /></td></tr>
<tr class="separator:gad2d21c12060a0af8631e34ba9edcd883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96498ee6fcadca7a579a1a3cd421ed1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa96498ee6fcadca7a579a1a3cd421ed1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gaa96498ee6fcadca7a579a1a3cd421ed1">AI_CACHE_BACKGROUND</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:gaa96498ee6fcadca7a579a1a3cd421ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all skydome importance tables for background. <br /></td></tr>
<tr class="separator:gaa96498ee6fcadca7a579a1a3cd421ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe3026e8e85e3a791936a581f915e9ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe3026e8e85e3a791936a581f915e9ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gabe3026e8e85e3a791936a581f915e9ac">AI_CACHE_QUAD</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:gabe3026e8e85e3a791936a581f915e9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all quad lights importance tables. <br /></td></tr>
<tr class="separator:gabe3026e8e85e3a791936a581f915e9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0aa9118fe67d4771c2a6fad5bdd151"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc0aa9118fe67d4771c2a6fad5bdd151"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__universe.html#gacc0aa9118fe67d4771c2a6fad5bdd151">AI_CACHE_ALL</a>&#160;&#160;&#160;0xFFFF</td></tr>
<tr class="memdesc:gacc0aa9118fe67d4771c2a6fad5bdd151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes all cache types simultaneously. <br /></td></tr>
<tr class="separator:gacc0aa9118fe67d4771c2a6fad5bdd151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The AiUniverse API provides access to global information about the scene. There is only one universe at any given time. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3f1e23717da6afbcc58352b04ce1279c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiUniverseIsActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the universe is active or not. </p>
<p>This function is typically used to detect whether we are inside an <a class="el" href="group__ai__render.html#ga0db5fe141c9fb602bdbf86a4d9cb77f7" title="Marks the beginning of a block which uses the Arnold rendering interface API. ">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API. ">AiEnd()</a> block.</p>
<dl class="section return"><dt>Returns</dt><dd>true if there is an active universe. This can only be false if called outside of an <a class="el" href="group__ai__render.html#ga0db5fe141c9fb602bdbf86a4d9cb77f7" title="Marks the beginning of a block which uses the Arnold rendering interface API. ">AiBegin()</a> / <a class="el" href="group__ai__render.html#gaeeda065dc5f0ef34f5e7621f5811eb4d" title="Marks the end of a block which uses the Arnold rendering interface API. ">AiEnd()</a> block. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaaf75f7ad717a03a79901f0ee59de45b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiUniverseCacheFlush </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush one or several caches in the current universe. </p>
<p>This function will release all memory associated with a cached resource. The next time that the resource is accessed, it will get reloaded or recomputed. This is useful in interactive rendering; occasionally, a texture map would need to be modified or updated in the middle of a relighting session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>a bitmask specifying the cache types to be flushed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the cache was flushed succesfully, false if rendering is still in progress </dd></dl>

</div>
</div>
<a class="anchor" id="gaa67e9b9b6fa73f729f35c8060fcf88d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a>* AiUniverseGetOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches the global options node. </p>
<p>Will return NULL if the scene does not exist yet.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the global options node </dd></dl>

</div>
</div>
<a class="anchor" id="gab78d93dd7b69b84f47896e042d7543a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtNode.html">AtNode</a>* AiUniverseGetCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches the currently active camera node. </p>
<p>Will return NULL if the scene does not exist, if the camera has not been set or if the linked node is not a camera.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to the active camera node </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ec9ad8303f46a7d2f758fcd7decf05e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtBBox.html">AtBBox</a> AiUniverseGetSceneBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounding box of the scene. </p>
<p>Note that this box may be conservative in the presence of "infinite" primitives or procedurals. If the scene has not been created yet, this will return an empty box containing the origin.</p>
<dl class="section return"><dt>Returns</dt><dd>scene bounding box </dd></dl>

</div>
</div>
<a class="anchor" id="ga0113dc8f5647d943d236bd3e74c7d3ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtNodeIterator* AiUniverseGetNodeIterator </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>node_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new node iterator and resets it to the first node in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_mask</td><td>bitmask of node types, e.g <code>AI_NODE_ALL</code>, <code>AI_NODE_LIGHT</code> | <code>AI_NODE_SHADER</code>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a node iterator over the given type of nodes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__universe.html#gac14e2b776f7e32dcb7346f64061f28ff" title="Destroys a node iterator when it is no longer needed. ">AiNodeIteratorDestroy</a>, <a class="el" href="group__ai__universe.html#ga9234a9aa9af990bcbb51ddd1313845d2" title="Returns current node and points node iterator to the next node. ">AiNodeIteratorGetNext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaae5d47235f2b455ab0f62780c292e546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtNodeEntryIterator* AiUniverseGetNodeEntryIterator </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>node_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new node entry iterator and resets it to the first installed node entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_mask</td><td>bitmask of node types, e.g <code>AI_NODE_ALL</code>, <code>AI_NODE_LIGHT</code> | <code>AI_NODE_SHADER</code>, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a node entry iterator over the given type of nodes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__universe.html#gacdbbbed549f79288819316f227def22f" title="Destroys a node entry iterator when it is no longer needed. ">AiNodeEntryIteratorDestroy</a>, <a class="el" href="group__ai__universe.html#gab8b0f41c673eb3a288f149dcea7b30bf" title="Returns current node entry and points node entry iterator to the next node entry. ...">AiNodeEntryIteratorGetNext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3adf42cc4d820f5952fccc8778e4d5f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtAOVIterator* AiUniverseGetAOVIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new AOV iterator and resets it to the first entry. </p>
<dl class="section return"><dt>Returns</dt><dd>a AOV iterator over all registered AOVs</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__ai__universe.html#gae3f61927424448febb6f7bd5b878b68d" title="Destroys a AOV iterator when it is no longer needed. ">AiAOVIteratorDestroy</a>, <a class="el" href="group__ai__universe.html#ga4f21d84d92bd3f5fc42c96afc94542e1" title="Returns current AOV entry and points AOV iterator to the next AOV. ">AiAOVIteratorGetNext</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac14e2b776f7e32dcb7346f64061f28ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtNodeIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a node iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>node iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9234a9aa9af990bcbb51ddd1313845d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNode.html">AtNode</a>* AiNodeIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtNodeIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current node and points node iterator to the next node. </p>
<p>This function is designed to be used inside a loop, as illustrated by the following example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtNodeIterator *iter = AiUniverseGetNodeIterator(AI_NODE_ALL);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;while (!AiNodeIteratorFinished(iter))</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   AtNode *node = AiNodeIteratorGetNext(iter);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   // do something with node ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;AiNodeIteratorDestroy(iter);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node pointed by the iterator, or <code>NULL</code> if there are no more nodes to iterate over </dd></dl>

</div>
</div>
<a class="anchor" id="gaed6b120df6cb2b6b57dc700d04d5f118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiNodeIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtNodeIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more nodes to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a node iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node iterator has moved past the last node </dd></dl>

</div>
</div>
<a class="anchor" id="gacdbbbed549f79288819316f227def22f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeEntryIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtNodeEntryIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a node entry iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>node entry iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab8b0f41c673eb3a288f149dcea7b30bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a>* AiNodeEntryIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtNodeEntryIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current node entry and points node entry iterator to the next node entry. </p>
<p>This function is designed to be used inside a loop, as illustrated by the following example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtNodeEntryIterator *iter = AiUniverseGetNodeEntryIterator(AI_NODE_ALL);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;while (!AiNodeEntryIteratorFinished(iter))</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   AtNodeEntry *node_entry = AiNodeEntryIteratorGetNext(iter);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   // do something with node_entry ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;AiNodeEntryIteratorDestroy(iter);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a node entry iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node entry pointed by the iterator, or <code>NULL</code> if there are no more node entries to iterate over </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b7978243ad260abcb7b6a7f2468aca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiNodeEntryIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtNodeEntryIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more node entries to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a node entry iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node entry iterator has moved past the last node entry </dd></dl>

</div>
</div>
<a class="anchor" id="gae3f61927424448febb6f7bd5b878b68d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiAOVIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtAOVIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a AOV iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>AOV iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f21d84d92bd3f5fc42c96afc94542e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const <a class="el" href="structAtAOVEntry.html">AtAOVEntry</a>* AiAOVIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtAOVIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current AOV entry and points AOV iterator to the next AOV. </p>
<p>This function is designed to be used inside a loop, as illustrated by the following example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AtAOVIterator* iter = AiUniverseGetAOVIterator();</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;while (!AiAOVIteratorFinished(iter))</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;   AtAOVEntry* aov_entry = AiAOVIteratorGetNext(iter);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   // do something with aov_entry ...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;AiAOVIteratorDestroy(iter);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>AOV iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the AOV pointed by the iterator, or <code>NULL</code> if there are no more AOV entries to iterate over </dd></dl>

</div>
</div>
<a class="anchor" id="gabdb557694ef170cb568d03cdc543ed8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiAOVIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtAOVIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more AOV entries to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a AOV iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the AOV iterator has moved past the last AOV </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2009-2016 Solid Angle SL &middot all rights reserved &middot <a href="http://www.solidangle.com"><font size=-2 color=#C9C9C9>www.solidangle.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
