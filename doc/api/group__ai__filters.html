<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Arnold 4.2.14.2 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Pixel Sample Filter Nodes</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtFilterNodeMethods.html">AtFilterNodeMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter Node methods structure.  <a href="structAtFilterNodeMethods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga764908fbc36660f1738ce353a4a05030"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga764908fbc36660f1738ce353a4a05030">AI_FILTER_NODE_EXPORT_METHODS</a>(tag)        </td></tr>
<tr class="memdesc:ga764908fbc36660f1738ce353a4a05030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter Node methods exporter.  <a href="#ga764908fbc36660f1738ce353a4a05030">More...</a><br /></td></tr>
<tr class="separator:ga764908fbc36660f1738ce353a4a05030"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaaba64375eee93511b8196af9a22dab85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaba64375eee93511b8196af9a22dab85"></a>
typedef struct <a class="el" href="structAtFilterNodeMethods.html">AtFilterNodeMethods</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#gaaba64375eee93511b8196af9a22dab85">AtFilterNodeMethods</a></td></tr>
<tr class="memdesc:gaaba64375eee93511b8196af9a22dab85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter Node methods structure. <br /></td></tr>
<tr class="separator:gaaba64375eee93511b8196af9a22dab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Method Declarations</h2></td></tr>
<tr class="memitem:ga51be8b24f90ffc8897a45a500874bdac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga51be8b24f90ffc8897a45a500874bdac">filter_output_type</a>&#160;&#160;&#160;static <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> FilterOutputType(const <a class="el" href="structAtNode.html">AtNode</a>* node, const <a class="el" href="unionAtParamValue.html">AtParamValue</a>* params, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> input_type)</td></tr>
<tr class="memdesc:ga51be8b24f90ffc8897a45a500874bdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter's filter_output_type method declaration.  <a href="#ga51be8b24f90ffc8897a45a500874bdac">More...</a><br /></td></tr>
<tr class="separator:ga51be8b24f90ffc8897a45a500874bdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758ca445ffc642feed4e7a2b856b22c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga758ca445ffc642feed4e7a2b856b22c3">filter_pixel</a>&#160;&#160;&#160;static void FilterPixel(<a class="el" href="structAtNode.html">AtNode</a>* node, <a class="el" href="unionAtParamValue.html">AtParamValue</a>* params, AtAOVSampleIterator* iterator, void* data_out, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> data_type)</td></tr>
<tr class="memdesc:ga758ca445ffc642feed4e7a2b856b22c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter's filter_pixel method declaration.  <a href="#ga758ca445ffc642feed4e7a2b856b22c3">More...</a><br /></td></tr>
<tr class="separator:ga758ca445ffc642feed4e7a2b856b22c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
API Methods for Filter Writers</h2></td></tr>
<tr class="memitem:gad9abbd011de96f1f52c6f440733fa966"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#gad9abbd011de96f1f52c6f440733fa966">AiFilterInitialize</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, bool requires_depth, const char **required_aovs, void *data)</td></tr>
<tr class="memdesc:gad9abbd011de96f1f52c6f440733fa966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an AOV filter.  <a href="#gad9abbd011de96f1f52c6f440733fa966">More...</a><br /></td></tr>
<tr class="separator:gad9abbd011de96f1f52c6f440733fa966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7c807193f66034695692e16fffb939"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga0e7c807193f66034695692e16fffb939">AiFilterUpdate</a> (<a class="el" href="structAtNode.html">AtNode</a> *node, float width)</td></tr>
<tr class="memdesc:ga0e7c807193f66034695692e16fffb939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates an AOV filter.  <a href="#ga0e7c807193f66034695692e16fffb939">More...</a><br /></td></tr>
<tr class="separator:ga0e7c807193f66034695692e16fffb939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3ceed9697697c93d087bb1eae025c0"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#gaff3ceed9697697c93d087bb1eae025c0">AiFilterDestroy</a> (<a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:gaff3ceed9697697c93d087bb1eae025c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter destructor.  <a href="#gaff3ceed9697697c93d087bb1eae025c0">More...</a><br /></td></tr>
<tr class="separator:gaff3ceed9697697c93d087bb1eae025c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25cc294a61be2aebb9931016fccd8cb6"><td class="memItemLeft" align="right" valign="top">AI_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga25cc294a61be2aebb9931016fccd8cb6">AiFilterGetLocalData</a> (const <a class="el" href="structAtNode.html">AtNode</a> *node)</td></tr>
<tr class="memdesc:ga25cc294a61be2aebb9931016fccd8cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve local data pointer for the specified filter.  <a href="#ga25cc294a61be2aebb9931016fccd8cb6">More...</a><br /></td></tr>
<tr class="separator:ga25cc294a61be2aebb9931016fccd8cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
API Methods to Loop over Samples</h2></td></tr>
<tr class="memitem:gaafd2f8222f7e8eab4253c11d16a1859d"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#gaafd2f8222f7e8eab4253c11d16a1859d">AiAOVSampleIteratorInitPixel</a> (AtAOVSampleIterator *iter, int x, int y)</td></tr>
<tr class="memdesc:gaafd2f8222f7e8eab4253c11d16a1859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the iterator for looping over the sample of the specified pixel.  <a href="#gaafd2f8222f7e8eab4253c11d16a1859d">More...</a><br /></td></tr>
<tr class="separator:gaafd2f8222f7e8eab4253c11d16a1859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96b1576b78e946941920480683360082"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga96b1576b78e946941920480683360082">AiAOVSampleIteratorReset</a> (AtAOVSampleIterator *iter)</td></tr>
<tr class="memdesc:ga96b1576b78e946941920480683360082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the iterator to its initial state (start of the same pixel).  <a href="#ga96b1576b78e946941920480683360082">More...</a><br /></td></tr>
<tr class="separator:ga96b1576b78e946941920480683360082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga489c53a857e136e54cde362c88878180"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga489c53a857e136e54cde362c88878180">AiAOVSampleIteratorGetNext</a> (AtAOVSampleIterator *iter)</td></tr>
<tr class="memdesc:ga489c53a857e136e54cde362c88878180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance iterator to next sample (or return false if none are left).  <a href="#ga489c53a857e136e54cde362c88878180">More...</a><br /></td></tr>
<tr class="separator:ga489c53a857e136e54cde362c88878180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9defe26ab5179a84104f0f97c8a6ddc3"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga9defe26ab5179a84104f0f97c8a6ddc3">AiAOVSampleIteratorGetNextDepth</a> (AtAOVSampleIterator *iter)</td></tr>
<tr class="memdesc:ga9defe26ab5179a84104f0f97c8a6ddc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator through the "deep" sample off of the current sub-pixel sample.  <a href="#ga9defe26ab5179a84104f0f97c8a6ddc3">More...</a><br /></td></tr>
<tr class="separator:ga9defe26ab5179a84104f0f97c8a6ddc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e9feea4fe9ea454600801b6980f51e"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="structAtPoint2.html">AtPoint2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga16e9feea4fe9ea454600801b6980f51e">AiAOVSampleIteratorGetOffset</a> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="memdesc:ga16e9feea4fe9ea454600801b6980f51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (x,y) offset from the pixel center.  <a href="#ga16e9feea4fe9ea454600801b6980f51e">More...</a><br /></td></tr>
<tr class="separator:ga16e9feea4fe9ea454600801b6980f51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaded3743c0a7162355a9e98637f8559df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaded3743c0a7162355a9e98637f8559df"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetInvDensity</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:gaded3743c0a7162355a9e98637f8559df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff1cd541e121c4bbbdc22f248f8efb39"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#gaff1cd541e121c4bbbdc22f248f8efb39">AiAOVSampleIteratorGetDepth</a> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="memdesc:gaff1cd541e121c4bbbdc22f248f8efb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depth of the current sample.  <a href="#gaff1cd541e121c4bbbdc22f248f8efb39">More...</a><br /></td></tr>
<tr class="separator:gaff1cd541e121c4bbbdc22f248f8efb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6050daf3788f592d00bfdaa8592fbb"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga8e6050daf3788f592d00bfdaa8592fbb">AiAOVSampleIteratorHasValue</a> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="memdesc:ga8e6050daf3788f592d00bfdaa8592fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the iterator has a value for the primary AOV at the current location.  <a href="#ga8e6050daf3788f592d00bfdaa8592fbb">More...</a><br /></td></tr>
<tr class="separator:ga8e6050daf3788f592d00bfdaa8592fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305e0e3e7fbe57a614b6f1eac93cb6fe"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__filters.html#ga305e0e3e7fbe57a614b6f1eac93cb6fe">AiAOVSampleIteratorHasAOVValue</a> (const AtAOVSampleIterator *iter, const char *name, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> type)</td></tr>
<tr class="memdesc:ga305e0e3e7fbe57a614b6f1eac93cb6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the iterator has a value for an arbitrary AOV at the current location.  <a href="#ga305e0e3e7fbe57a614b6f1eac93cb6fe">More...</a><br /></td></tr>
<tr class="separator:ga305e0e3e7fbe57a614b6f1eac93cb6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
API Methods to Get Sample Value from Iterator</h2></td></tr>
<tr class="memitem:gaa7693dc8828302d6b148f6e263c910fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7693dc8828302d6b148f6e263c910fd"></a>
AI_API AI_PURE bool&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetBool</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:gaa7693dc8828302d6b148f6e263c910fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41cd398a32e13b19a05bbd8045940ec3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41cd398a32e13b19a05bbd8045940ec3"></a>
AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetInt</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:ga41cd398a32e13b19a05bbd8045940ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4548e36c15d4e5b6023e42d0f32e222b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4548e36c15d4e5b6023e42d0f32e222b"></a>
AI_API AI_PURE float&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetFlt</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:ga4548e36c15d4e5b6023e42d0f32e222b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8eafcc3a04ba47d9be41b9563296b9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8eafcc3a04ba47d9be41b9563296b9c"></a>
AI_API AI_PURE <a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetRGB</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:gaa8eafcc3a04ba47d9be41b9563296b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd2a4496a3b108899f4eb69811131db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8fd2a4496a3b108899f4eb69811131db"></a>
AI_API AI_PURE <a class="el" href="structAtRGBA.html">AtRGBA</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetRGBA</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:ga8fd2a4496a3b108899f4eb69811131db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce96bace5f88649470e9a73814f6dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ce96bace5f88649470e9a73814f6dcb"></a>
AI_API AI_PURE <a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetVec</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:ga4ce96bace5f88649470e9a73814f6dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7178d467708541a5b2da911d826e2219"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7178d467708541a5b2da911d826e2219"></a>
AI_API AI_PURE <a class="el" href="structAtPoint.html">AtPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetPnt</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:ga7178d467708541a5b2da911d826e2219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cbbc7d452449ca88f72857fd1dc0fa8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9cbbc7d452449ca88f72857fd1dc0fa8"></a>
AI_API AI_PURE <a class="el" href="structAtPoint2.html">AtPoint2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetPnt2</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:ga9cbbc7d452449ca88f72857fd1dc0fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f0e06f2fb93d805bf1f67110474a779"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f0e06f2fb93d805bf1f67110474a779"></a>
AI_API AI_PURE const void *&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetPtr</b> (const AtAOVSampleIterator *iter)</td></tr>
<tr class="separator:ga8f0e06f2fb93d805bf1f67110474a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
API Methods to Get Sample Value from Iterator for an Arbitrary AOV</h2></td></tr>
<tr class="memitem:gaf629561b81096fce7aad1b22b0ac0bc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf629561b81096fce7aad1b22b0ac0bc8"></a>
AI_API const char *&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:gaf629561b81096fce7aad1b22b0ac0bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbc85fb0a8e3c5b4877ed0b365a23e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaecbc85fb0a8e3c5b4877ed0b365a23e5"></a>
AI_API&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((pure)) bool AiAOVSampleIteratorGetAOVBool(const AtAOVSampleIterator *iter</td></tr>
<tr class="separator:gaecbc85fb0a8e3c5b4877ed0b365a23e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845fd1a98bdb54cfe806628dc19e9646"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga845fd1a98bdb54cfe806628dc19e9646"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVBool</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:ga845fd1a98bdb54cfe806628dc19e9646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a7f735324479ba27433da943e70ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08a7f735324479ba27433da943e70ba1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVInt</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:ga08a7f735324479ba27433da943e70ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fa3b7e106d5c89040bfad41a5d7c6ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3fa3b7e106d5c89040bfad41a5d7c6ac"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVFlt</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:ga3fa3b7e106d5c89040bfad41a5d7c6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac70fd0b63a767515d8eecc1134ca5c67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac70fd0b63a767515d8eecc1134ca5c67"></a>
<a class="el" href="structAtRGB.html">AtRGB</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVRGB</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:gac70fd0b63a767515d8eecc1134ca5c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab009b310483042f7c8bbe5c0cff58bf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab009b310483042f7c8bbe5c0cff58bf4"></a>
<a class="el" href="structAtRGBA.html">AtRGBA</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVRGBA</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:gab009b310483042f7c8bbe5c0cff58bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71374b05c69d7872ad0ebb1275edbad9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga71374b05c69d7872ad0ebb1275edbad9"></a>
<a class="el" href="group__ai__vector.html#ga5ebd05ce268e7c95e95f8c7f4668c5c2">AtVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVVec</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:ga71374b05c69d7872ad0ebb1275edbad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d3a75c849e25814b0c38fdeb7821754"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d3a75c849e25814b0c38fdeb7821754"></a>
<a class="el" href="structAtPoint.html">AtPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVPnt</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:ga4d3a75c849e25814b0c38fdeb7821754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a839cccbc0d04ed5ba35f235b17dd86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a839cccbc0d04ed5ba35f235b17dd86"></a>
<a class="el" href="structAtPoint2.html">AtPoint2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVPnt2</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:ga8a839cccbc0d04ed5ba35f235b17dd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac042c9331fd6e89944d8f22fb2bd887d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac042c9331fd6e89944d8f22fb2bd887d"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>AiAOVSampleIteratorGetAOVPtr</b> (const AtAOVSampleIterator *iter, const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="separator:gac042c9331fd6e89944d8f22fb2bd887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Arnold has support for pluggable sample filters. The filter will process a bucket of AOV subsamples and filter them down to a single AOV sample per pixel.</p>
<p>Filters operate on a "primary" AOV; this is the AOV which is specified on the same "outputs" line as where the filter is specified. However, filters can also query supporting, or auxiliary, AOVs which can assist in filtering. These are specified when a filter is initialized (see <a class="el" href="group__ai__filters.html#gad9abbd011de96f1f52c6f440733fa966" title="Initializes an AOV filter. ">AiFilterInitialize()</a>). </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga764908fbc36660f1738ce353a4a05030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AI_FILTER_NODE_EXPORT_METHODS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tag</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__ai__filters.html#ga51be8b24f90ffc8897a45a500874bdac">AI_INSTANCE_COMMON_METHODS                      \</a></div><div class="line"><a class="code" href="group__ai__filters.html#ga51be8b24f90ffc8897a45a500874bdac">filter_output_type</a>;                             <a class="code" href="group__ai__filters.html#ga758ca445ffc642feed4e7a2b856b22c3">\</a></div><div class="line"><a class="code" href="group__ai__filters.html#ga758ca445ffc642feed4e7a2b856b22c3">filter_pixel</a>;                                   \</div><div class="line">static <a class="code" href="structAtFilterNodeMethods.html">AtFilterNodeMethods</a> ai_filter_mtds = {   \</div><div class="line">   FilterOutputType,                            \</div><div class="line">   FilterPixel                                  \</div><div class="line">};                                              \</div><div class="line">static <a class="code" href="structAtNodeMethods.html">AtNodeMethods</a> ai_node_mtds = {           \</div><div class="line">   &amp;ai_common_mtds,                             \</div><div class="line">   &amp;ai_filter_mtds                              \</div><div class="line">};                                              \</div><div class="line">AtNodeMethods *tag = &amp;ai_node_mtds;</div><div class="ttc" id="group__ai__filters_html_ga51be8b24f90ffc8897a45a500874bdac"><div class="ttname"><a href="group__ai__filters.html#ga51be8b24f90ffc8897a45a500874bdac">filter_output_type</a></div><div class="ttdeci">#define filter_output_type</div><div class="ttdoc">Filter&amp;#39;s filter_output_type method declaration. </div><div class="ttdef"><b>Definition:</b> ai_filters.h:76</div></div>
<div class="ttc" id="structAtFilterNodeMethods_html"><div class="ttname"><a href="structAtFilterNodeMethods.html">AtFilterNodeMethods</a></div><div class="ttdoc">Filter Node methods structure. </div><div class="ttdef"><b>Definition:</b> ai_filters.h:36</div></div>
<div class="ttc" id="structAtNodeMethods_html"><div class="ttname"><a href="structAtNodeMethods.html">AtNodeMethods</a></div><div class="ttdoc">Node methods. </div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:56</div></div>
<div class="ttc" id="group__ai__filters_html_ga758ca445ffc642feed4e7a2b856b22c3"><div class="ttname"><a href="group__ai__filters.html#ga758ca445ffc642feed4e7a2b856b22c3">filter_pixel</a></div><div class="ttdeci">#define filter_pixel</div><div class="ttdoc">Filter&amp;#39;s filter_pixel method declaration. </div><div class="ttdef"><b>Definition:</b> ai_filters.h:93</div></div>
</div><!-- fragment -->
<p>Filter Node methods exporter. </p>

</div>
</div>
<a class="anchor" id="ga51be8b24f90ffc8897a45a500874bdac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define filter_output_type&#160;&#160;&#160;static <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> FilterOutputType(const <a class="el" href="structAtNode.html">AtNode</a>* node, const <a class="el" href="unionAtParamValue.html">AtParamValue</a>* params, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> input_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter's filter_output_type method declaration. </p>
<p>This function describes how a pixel sample filter will map a particular input type to an output type. For example, if a filter is asked to filter an Integer AOV, then the filter might decide to convert the integers to floats first and then output a float containing the filtered values. Most filters' "output" type will match their "input" type. The system will use this information to ensure that a filter is only connected to an output driver which can write the filter's output type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The filter node </td></tr>
    <tr><td class="paramname">params</td><td>The filter node's parameters array </td></tr>
    <tr><td class="paramname">input_type</td><td>A particular input type (e.g. <code>AI_TYPE_RGB</code>, AI_TYPE_FLOAT, etc) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the output type of this filter for a given input type </dd></dl>

</div>
</div>
<a class="anchor" id="ga758ca445ffc642feed4e7a2b856b22c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define filter_pixel&#160;&#160;&#160;static void FilterPixel(<a class="el" href="structAtNode.html">AtNode</a>* node, <a class="el" href="unionAtParamValue.html">AtParamValue</a>* params, AtAOVSampleIterator* iterator, void* data_out, <a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a> data_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter's filter_pixel method declaration. </p>
<p>This function peforms pixel filtering. Generally, this function will contain a loop which iterates over all the samples of the primary AOV which are contained in this pixel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The filter node </td></tr>
    <tr><td class="paramname">params</td><td>The filter node's parameter list </td></tr>
    <tr><td class="paramname">iterator</td><td>An iterator which the filter uses to iterate over all the samples of the primary AOV for the current pixel. The user advances to the next sample by calling <a class="el" href="group__ai__filters.html#ga489c53a857e136e54cde362c88878180" title="Advance iterator to next sample (or return false if none are left). ">AiAOVSampleIteratorGetNext()</a>. </td></tr>
    <tr><td class="paramname">data_out</td><td>A pointer to where the filter writes the filtered pixel output. </td></tr>
    <tr><td class="paramname">data_type</td><td>This contains the data-type of the primary AOV. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad9abbd011de96f1f52c6f440733fa966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiFilterInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requires_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>required_aovs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an AOV filter. </p>
<p>This function must be called by a pluggable AOV-filter when the node is initialized in the <code>node_initialize</code> method. It serves to initialize the filter and instructs the system as to the capabilities/requirements of the filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The pointer to the filter's node </td></tr>
    <tr><td class="paramname">requires_depth</td><td>A boolean telling the system whether this filter is capable of filtering both spatially <em>and</em> with respect to sample depth. If this boolean is set to true, then the system will store all the writes of the required AOVs regardless of depth. </td></tr>
    <tr><td class="paramname">required_aovs</td><td>This is a list of the AOVs required by this filter in order to perform filtering. Some filters require "auxiliary" AOVs to assist in filtering the primary AOV. For example, a "closest_filter" would require an AOV containing depth information in order to find the closest occurence of the primary AOV. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to data local to a particular instance of a filter node. This pointer can be retrieved by calling <a class="el" href="group__ai__filters.html#ga25cc294a61be2aebb9931016fccd8cb6" title="Retrieve local data pointer for the specified filter. ">AiFilterGetLocalData()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e7c807193f66034695692e16fffb939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiFilterUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates an AOV filter. </p>
<p>This function must be called by a pluggable AOV-filter when the node is updated in the <code>node_update</code> method. It will reconfigure the filter taking into account any change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The pointer to the filter's node </td></tr>
    <tr><td class="paramname">width</td><td>The width of the filter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaff3ceed9697697c93d087bb1eae025c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiFilterDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter destructor. </p>
<p>This function serves to destroy and unregister a particular AOV filter from the system. This should be called in a filter node's <code>node_finish</code> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the filter node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga25cc294a61be2aebb9931016fccd8cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void* AiFilterGetLocalData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNode.html">AtNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve local data pointer for the specified filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the filter node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Local data pointer, as passed to <a class="el" href="group__ai__filters.html#gad9abbd011de96f1f52c6f440733fa966" title="Initializes an AOV filter. ">AiFilterInitialize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaafd2f8222f7e8eab4253c11d16a1859d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiAOVSampleIteratorInitPixel </td>
          <td>(</td>
          <td class="paramtype">AtAOVSampleIterator *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the iterator for looping over the sample of the specified pixel. </p>
<p>This method only needs to be called inside raw drivers which need to access multiple pixels. Regular filters receive an iterator which has already been initialized to the correct pixel location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the sample iterator </td></tr>
    <tr><td class="paramname">x</td><td>x pixel coordinate </td></tr>
    <tr><td class="paramname">y</td><td>y pixel coordinate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga96b1576b78e946941920480683360082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiAOVSampleIteratorReset </td>
          <td>(</td>
          <td class="paramtype">AtAOVSampleIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the iterator to its initial state (start of the same pixel). </p>
<p>This can be useful for filters or raw drivers which need to loop over the same pixel several times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the sample iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga489c53a857e136e54cde362c88878180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiAOVSampleIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtAOVSampleIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance iterator to next sample (or return false if none are left). </p>
<p>This function should be called inside a while loop to process all available samples.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the sample iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true while more samples are available </dd></dl>

</div>
</div>
<a class="anchor" id="ga9defe26ab5179a84104f0f97c8a6ddc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiAOVSampleIteratorGetNextDepth </td>
          <td>(</td>
          <td class="paramtype">AtAOVSampleIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the iterator through the "deep" sample off of the current sub-pixel sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the sample iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true while more "deep" samples are available </dd></dl>

</div>
</div>
<a class="anchor" id="ga16e9feea4fe9ea454600801b6980f51e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="structAtPoint2.html">AtPoint2</a> AiAOVSampleIteratorGetOffset </td>
          <td>(</td>
          <td class="paramtype">const AtAOVSampleIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (x,y) offset from the pixel center. </p>
<p>This can be used to compute the exact weight a sample should receive. Each component is guaranteed to lie within the filter radius. Raw-drivers only have a radius of 0.5 (one pixel wide).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the sample iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the x,y offset from the pixel center </dd></dl>

</div>
</div>
<a class="anchor" id="gaff1cd541e121c4bbbdc22f248f8efb39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiAOVSampleIteratorGetDepth </td>
          <td>(</td>
          <td class="paramtype">const AtAOVSampleIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the depth of the current sample. </p>
<p>This is only useful for deep raw drivers or deep-filters which need to examine more than one hit within a pixel. The depth is numbered such that the sample closest to the screen is depth=0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the sample iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>depth of the current sample </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e6050daf3788f592d00bfdaa8592fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiAOVSampleIteratorHasValue </td>
          <td>(</td>
          <td class="paramtype">const AtAOVSampleIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the iterator has a value for the primary AOV at the current location. </p>
<p>The primary is defined by the filter. Not all samples are guaranteed to have a value. It is generally safe to avoid calling this method unless the sample count is of specific importance. Samples that did not receive a value will be 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the sample iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a value was written to this sample </dd></dl>

</div>
</div>
<a class="anchor" id="ga305e0e3e7fbe57a614b6f1eac93cb6fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE bool AiAOVSampleIteratorHasAOVValue </td>
          <td>(</td>
          <td class="paramtype">const AtAOVSampleIterator *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ai__types.html#ga41f7f394ad3ef67901cce4d05bdabf89">AtByte</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the iterator has a value for an arbitrary AOV at the current location. </p>
<p>Not all samples are guaranteed to have a value. It is generally safe to avoid calling this method unless the sample count is of specific importance. Samples that did not receive a value will be 0. The AOV queried must have been requested as a secondary AOV from the filter or the raw-driver in order to be visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the sample iterator </td></tr>
    <tr><td class="paramname">name</td><td>name of the AOV to lookup </td></tr>
    <tr><td class="paramname">type</td><td>type of the AOV to lookup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a value was written to this sample for the specified AOV </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2009-2016 Solid Angle SL &middot all rights reserved &middot <a href="http://www.solidangle.com"><font size=-2 color=#C9C9C9>www.solidangle.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
